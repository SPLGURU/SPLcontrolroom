<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Control Room V2</title>
    <!-- Firebase SDK - Core -->
    <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js"></script>
    <!-- Firebase SDK - Auth -->
    <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js"></script>
    <!-- Firebase SDK - Firestore -->
    <script type="module" src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> 
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style id="main-styles">
        /* Base colors for light mode */
        :root {
            --spl-light-bg: #F8F9FA; --spl-container-bg: #FFFFFF; --spl-table-bg: #E0E4E8;
            --spl-table-header-bg: #B3D9FF; --spl-table-row-even: #D6DBE0; --spl-table-row-hover: #C7CCD1;
            --spl-text-dark: #212529; --spl-text-medium: #495057; --spl-primary-accent: #034667;
            --spl-accent-green: #28A745; --spl-accent-red: #DC3545; --spl-border-light: #CED4DA;
            --spl-shadow: rgba(0, 0, 0, 0.1);
        }

        /* Dark mode specific variables */
        body.dark-mode {
            --spl-light-bg: #034667; --spl-container-bg: #1a3e5c; --spl-table-bg: #0d283c;
            --spl-table-header-bg: #0a1c2a; --spl-table-row-even: #123045; --spl-table-row-hover: #1f4f7a;
            --spl-text-dark: #F8F9FA; --spl-text-medium: #CED4DA; --spl-primary-accent: #007bff;
            --spl-border-light: #495057; --spl-shadow: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--spl-light-bg); color: var(--spl-text-dark);
            margin: 0; padding: 20px; line-height: 1.6; display: flex; flex-direction: column;
            align-items: center; min-height: 100vh; box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        #logo-container { text-align: center; margin-bottom: 20px; width: 100%; }
        #logo-container img { max-width: 300px; height: auto; display: block; margin: 0 auto; transition: src 0.3s ease; }

        /* Theme switch styles */
        .theme-switch-wrapper { display: flex; align-items: center; justify-content: center; margin-bottom: 20px; gap: 10px; color: var(--spl-text-dark); font-size: 0.95em; width: 100%; max-width: 1200px; }
        .theme-switch { position: relative; display: inline-block; width: 45px; height: 25px; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; -webkit-transition: .4s; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; -webkit-transition: .4s; transition: .4s; }
        input:checked + .slider { background-color: var(--spl-primary-accent); }
        input:focus + .slider { box-shadow: 0 0 1px var(--spl-primary-accent); }
        input:checked + .slider:before { -webkit-transform: translateX(20px); -ms-transform: translateX(20px); transform: translateX(20px); }
        .slider.round { border-radius: 25px; }
        .slider.round:before { border-radius: 50%; }
        body.dark-mode .theme-switch .slider { background-color: #555; }
        body.dark-mode input:checked + .slider { background-color: var(--spl-primary-accent); }
        body.dark-mode .theme-label { color: var(--spl-text-dark); }

        .container {
            background-color: var(--spl-container-bg); border-radius: 12px; box-shadow: 0 6px 12px var(--spl-shadow);
            padding: 30px; margin-bottom: 20px; width: 100%; max-width: 1200px; box-sizing: border-box;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        h1, h2, h3 { font-family: 'Oswald', sans-serif; color: var(--spl-primary-accent); text-align: center; margin-top: 0; margin-bottom: 20px; transition: color 0.3s ease; }
        
        .input-section { display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 30px; }

        /* Login/Signup Forms */
        #authSection { display: flex; flex-direction: column; align-items: center; width: 100%; }
        #loginForm, #signupForm { display: flex; flex-direction: column; align-items: center; gap: 15px; width: 100%; max-width: 400px; margin: 0 auto; padding-bottom: 15px; box-sizing: border-box; }
        #loginForm input, #signupForm input { display: block; width: 100%; max-width: 300px; margin: 0 auto; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 1em; box-sizing: border-box; text-align: left; background-color: var(--spl-container-bg); color: var(--spl-text-dark); transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; -moz-appearance: textfield; }
        .input-section input::-webkit-outer-spin-button, .input-section input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        #loginForm button, #signupForm button { display: block; width: 100%; max-width: 300px; margin: 0 auto; background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; font-size: 1.1em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
        #loginForm button:hover, #signupForm button:hover { background-color: #0056b3; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25); }
        #loginForm p, #signupForm p { text-align: center; width: 100%; max-width: 300px; margin: 10px auto; color: var(--spl-text-dark); transition: color 0.3s ease; }
        #loginForm p a, #signupForm p a { color: var(--spl-primary-accent); text-decoration: none; font-weight: bold; transition: color 0.3s ease; }
        #loginForm p a:hover, #signupForm p a:hover { text-decoration: underline; }

        .input-section label { font-weight: bold; color: var(--spl-text-medium); font-size: 1.1em; transition: color 0.3s ease; }
        .input-section button { background-color: var(--spl-primary-accent); color: white; padding: 12px 25px; border: none; border-radius: 8px; font-size: 1.1em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2); display: block; margin: 0 auto; }
        .input-section button:hover { background-color: #0056b3; transform: translateY(-2px); }

        /* Menu Styles */
        #menuToggle { position: fixed; top: 20px; left: 20px; z-index: 1001; cursor: pointer; font-size: 2em; color: var(--spl-primary-accent); transition: color 0.3s ease; display: none; }
        body.dark-mode #menuToggle { color: #fff; }
        #sidebarMenu { position: fixed; top: 0; left: -300px; width: 280px; height: 100%; background-color: var(--spl-container-bg); box-shadow: 3px 0 10px rgba(0, 0, 0, 0.2); z-index: 1000; transition: left 0.3s ease-in-out; padding-top: 20px; display: flex; flex-direction: column; gap: 10px; box-sizing: border-box; }
        body.dark-mode #sidebarMenu { background-color: var(--spl-container-bg); }
        #sidebarMenu.open { left: 0; }
        #sidebarMenu a { padding: 15px 25px; text-decoration: none; color: var(--spl-text-dark); font-size: 1.1em; display: block; transition: background-color 0.2s ease, color 0.2s ease; border-left: 5px solid transparent; }
        #sidebarMenu a:hover { background-color: var(--spl-table-row-hover); color: var(--spl-primary-accent); }
        body.dark-mode #sidebarMenu a { color: var(--spl-text-dark); }
        body.dark-mode #sidebarMenu a:hover { background-color: var(--spl-table-row-hover); color: var(--spl-primary-accent); }
        .red-button { background-color: #DC3545 !important; color: white !important; padding: 10px 20px !important; border: none !important; border-radius: 4px !important; font-size: 1.1em !important; cursor: pointer !important; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease !important; box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2) !important; display: block; width: calc(100% - 50px); margin: 10px auto; }
        .red-button:hover { background-color: #c82333 !important; transform: translateY(-1px) !important; box-shadow: 0 4px 8px rgba(220, 53, 69, 0.25); }
        body.dark-mode .red-button { background-color: #f44336 !important; box-shadow: 0 44px 8px rgba(244, 67, 54, 0.2) !important; }
        body.dark-mode .red-button:hover { background-color: #d32f2f !important; }
        #sidebarHeader { padding: 15px 25px 10px; font-family: 'Oswald', sans-serif; color: var(--spl-primary-accent); font-size: 1.2em; font-weight: bold; border-bottom: 1px solid var(--spl-border-light); margin-bottom: 10px; display: flex; align-items: center; justify-content: center; text-align: center; }
        body.dark-mode #sidebarHeader { color: var(--spl-text-dark); border-bottom-color: var(--spl-border-light); }
        #sidebarTeamName { color: var(--spl-primary-accent); display: block; margin-top: 5px; }
        body.dark-mode #sidebarTeamName { color: #FFD700; }
        #sidebarManagerIdText { padding: 10px 25px; font-size: 0.95em; color: var(--spl-text-medium); margin-top: 10px; margin-bottom: 10px; text-align: center; border-top: 1px solid var(--spl-border-light); padding-top: 15px; }
        body.dark-mode #sidebarManagerIdText { color: var(--spl-text-medium); border-top-color: var(--spl-border-light); }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 999; display: none; }

        /* Admin Dashboard Styles */
        #adminDashboardContent { display: flex; flex-direction: column; align-items: center; gap: 20px; padding: 20px; margin-top: 20px; border-radius: 12px; background-color: var(--spl-container-bg); box-shadow: 0 4px 8px var(--spl-shadow); width: 100%; max-width: 600px; box-sizing: border-box; min-height: 200px; margin-left: auto; margin-right: auto; }
        body.dark-mode #adminDashboardContent { background-color: var(--spl-container-bg); }
        #adminDashboardContent h2 { color: var(--spl-primary-accent); margin-bottom: 15px; }
        .admin-search-section, .admin-edit-section { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .admin-search-section input, .admin-edit-section input { width: 100%; max-width: 350px; padding: 10px 12px; border: 1px solid var(--spl-border-light); border-radius: 6px; font-size: 1em; background-color: var(--spl-table-bg); color: var(--spl-text-dark); box-sizing: border-box; text-align: center; }
        .admin-search-section button, .admin-edit-section button { background-color: #6c757d; color: white; padding: 10px 20px; border: none; border-radius: 6px; font-size: 1em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); width: 100%; max-width: 350px; }
        .admin-search-section button:hover, .admin-edit-section button:hover { background-color: #5a6268; transform: translateY(-1px); }
        body.dark-mode .admin-search-section button, body.dark-mode .admin-edit-section button { background-color: #6f42c1; box-shadow: 0 4px 8px rgba(111, 66, 193, 0.2); }
        body.dark-mode .admin-search-section button:hover, body.dark-mode .admin-edit-section button:hover { background-color: #5e35b1; }
        #adminSearchResults p { font-size: 1em; color: var(--spl-text-dark); margin-bottom: 5px; text-align: center; width: 100%; }
        #adminSearchResults strong { color: var(--spl-primary-accent); }
        #adminMessage { text-align: center; padding: 10px; border-radius: 6px; margin-top: 10px; font-weight: bold; background-color: #d1ecf1; color: #0c5460; width: 100%; max-width: 350px; box-sizing: border-box; display: none; }
        body.dark-mode #adminMessage { background-color: #1f3d54; color: #b0e0e6; }
        .admin-dashboard-nav-buttons { display: flex; justify-content: center; gap: 15px; width: 100%; margin-bottom: 20px; }
        .admin-dashboard-nav-buttons button { background-color: var(--spl-primary-accent); color: white; padding: 10px 20px; border: none; border-radius: 6px; font-size: 1em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); min-width: 120px; }
        .admin-dashboard-nav-buttons button:hover { background-color: #0056b3; transform: translateY(-1px); }
        body.dark-mode .admin-dashboard-nav-buttons button { background-color: #007bff; }
        body.dark-mode .admin-dashboard-nav-buttons button:hover { background-color: #0056b3; }

        .message-box { text-align: center; padding: 15px; border-radius: 8px; margin-top: 15px; font-weight: bold; display: none; }
        .message-box.success { background-color: #d4edda; color: #155724; }
        .message-box.error { background-color: #f8d7da; color: #721c24; }
        .message-box.info { background-color: #d1ecf1; color: #0c5460; }
        .message-box.warning { background-color: #fff3cd; color: #856404; } 

        .loading-message, .error-message { text-align: center; padding: 20px; border-radius: 8px; margin-top: 20px; font-weight: bold; transition: background-color 0.3s ease, color 0.3s ease; }
        .loading-message { background-color: #e0f7fa; color: #007BFF; }
        .error-message { background-color: #ffe0e6; color: #DC3545; border: 1px solid #DC3545; }

        /* Responsive Adjustments */
        @media (max-width: 950px) { body { padding: 15px; } .container { padding: 20px; } #loginForm input, #signupForm input, #loginForm button, #signupForm button { font-size: 0.95em; padding: 10px 20px; } }
        @media (max-width: 480px) { h1 { font-size: 1.8em; } h2 { font-size: 1.4em; } .input-section { gap: 10px; } }

        .instructions { background-color: #e9ecef; border-left: 5px solid var(--spl-primary-accent); padding: 15px 20px; margin-top: 20px; border-radius: 8px; font-size: 0.95em; color: var(--spl-text-dark); line-height: 1.5; width: 100%; max-width: 600px; box-sizing: border-box; text-align: left; transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; }
        .instructions h3 { color: var(--spl-primary-accent); margin-top: 0; margin-bottom: 10px; text-align: left; transition: color 0.3s ease; }
        .instructions ol { margin-left: 20px; padding-left: 0; }
        .instructions li { margin-bottom: 8px; }
        .instructions a { color: var(--spl-primary-accent); text-decoration: none; font-weight: bold; transition: color 0.3s ease; }
        .instructions a:hover { text-decoration: underline; }
        body.dark-mode .instructions { background-color: var(--spl-light-bg); border-left-color: var(--spl-primary-accent); color: var(--spl-text-dark); }
        body.dark-mode .instructions h3, body.dark-mode .instructions a { color: #FFD700; }

        /* FDR Difficulty Scale Colors */
        .fdr-scale { display: flex; justify-content: center; align-items: center; margin-bottom: 15px; font-weight: bold; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.1); width: 100%; max-width: 700px; margin-left: auto; margin-right: auto; }
        .fdr-level { padding: 8px 12px; text-align: center; color: black; flex-grow: 1; min-width: 50px; transition: background-color 0.3s ease, color 0.3s ease; }
        .fdr-level span { display: block; font-size: 0.8em; margin-top: 2px; }
        .fdr-1 { background-color: #00B050; color: white; } .fdr-2 { background-color: #92D050; color: black; }
        .fdr-3 { background-color: #FFFF00; color: black; } .fdr-4 { background-color: #FFC000; color: black; }
        .fdr-5 { background-color: #FF0000; color: white; } .fdr-6 { background-color: #C00000; color: white; }
        .fdr-7 { background-color: #800000; color: white; }
        body.dark-mode .fdr-level { color: white; }
        body.dark-mode .fdr-2, body.dark-mode .fdr-3, body.dark-mode .fdr-4 { color: black; }
        body.dark-mode .fdr-1 { background-color: #008037; } body.dark-mode .fdr-2 { background-color: #6B9F3B; }
        body.dark-mode .fdr-3 { background-color: #B3B300; } body.dark-mode .fdr-4 { background-color: #B38600; }
        body.dark-mode .fdr-5 { background-color: #B30000; } body.dark-mode .fdr-6 { background-color: #800000; }
        body.dark-mode .fdr-7 { background-color: #530000; }

        /* FDR Display Grids */
        .fdr-data-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0; border: 1px solid var(--spl-border-light); border-radius: 8px; overflow: hidden; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); }
        body.dark-mode .fdr-data-grid { border-color: rgba(255,255,255,0.1); box-shadow: inset 0 0 5px rgba(255,255,255,0.05); }
        .fdr-single-column-grid { display: grid; grid-template-columns: 1fr; gap: 0; border: 1px solid var(--spl-border-light); border-radius: 8px; overflow: hidden; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); }
        body.dark-mode .fdr-single-column-grid { border-color: rgba(255,255,255,0.1); box-shadow: inset 0 0 5px rgba(255,255,255,0.05); }
        .fdr-grid-item { padding: 10px 15px; text-align: center; font-weight: bold; font-size: 0.95em; display: flex; align-items: center; justify-content: center; gap: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: black; min-height: 45px; box-sizing: border-box; border-bottom: 1px solid var(--spl-border-light); transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
        body.dark-mode .fdr-grid-item { color: white; border-bottom-color: rgba(255,255,255,0.1); }
        .fdr-data-grid .fdr-grid-item:nth-child(2n-1) { border-right: 1px solid var(--spl-border-light); transition: border-color 0.3s ease; }
        body.dark-mode .fdr-data-grid .fdr-grid-item:nth-child(2n-1) { border-right-color: rgba(255,255,255,0.1); }
        .fdr-data-grid > :nth-last-child(-n + 2) { border-bottom: none; }
        .fdr-single-column-grid > :last-child { border-bottom: none; }

        .upload-button-label { display: inline-block; background-color: var(--spl-primary-accent); color: white; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 1em; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); margin-top: 10px; }
        .upload-button-label:hover { background-color: #0056b3; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }
        .upload-button-label input[type="file"] { display: none; }
        @media (max-width: 480px) { .fdr-grid-item { font-size: 0.8em; padding: 8px 10px; min-height: 35px; } }

        /* FDR System Selection */
        .fdr-system-selection { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; flex-wrap: wrap; }
        .fdr-system-selection label { display: flex; align-items: center; cursor: pointer; font-weight: bold; color: var(--spl-text-dark); transition: color 0.3s ease; }
        .fdr-system-selection input[type="radio"] { margin-right: 8px; accent-color: var(--spl-primary-accent); transform: scale(1.2); }
        .fdr-system-selection button { background-color: var(--spl-primary-accent); color: white; padding: 8px 15px; border: none; border-radius: 6px; font-size: 0.9em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .fdr-system-selection button:hover { background-color: #0056b3; transform: translateY(-1px); }
        body.dark-mode .fdr-system-selection label { color: var(--spl-text-dark); }
        body.dark-mode .fdr-system-selection button { background-color: #007bff; }
        body.dark-mode .fdr-system-selection button:hover { background-color: #0056b3; }

        /* Fixture Item Display */
        .fixture-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid var(--spl-border-light); background-color: var(--spl-container-bg); transition: background-color 0.3s ease; }
        .fixture-item:last-child { border-bottom: none; }
        .fixture-item span { font-weight: bold; color: var(--spl-text-dark); }
        .fixture-item .fdr-value { padding: 5px 10px; border-radius: 5px; font-weight: bold; color: white; min-width: 40px; text-align: center; }
        body.dark-mode .fixture-item { background-color: var(--spl-container-bg); border-bottom-color: rgba(255,255,255,0.1); }
        body.dark-mode .fixture-item span { color: var(--spl-text-dark); }
        .fixtures-list-container { border: 1px solid var(--spl-border-light); border-radius: 8px; overflow: hidden; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); margin-top: 20px; max-width: 400px; width: 100%; margin-left: auto; margin-right: auto; }
        body.dark-mode .fixtures-list-container { border-color: rgba(255,255,255,0.1); box-shadow: inset 0 0 5px rgba(255,255,255,0.05); }
        .fdr-section-title { text-align: center; font-size: 1.1em; font-weight: bold; color: var(--spl-primary-accent); margin-top: 20px; margin-bottom: 15px; }
        body.dark-mode .fdr-section-title { color: #FFD700; }

        /* Customized FDR inputs */
        .custom-ratings-input-grid-container { margin-top: 15px; border: 1px solid var(--spl-border-light); border-radius: 8px; overflow: hidden; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); background-color: var(--spl-container-bg); width: 100%; max-width: 400px; margin-left: auto; margin-right: auto; display: none; }
        body.dark-mode .custom-ratings-input-grid-container { border-color: rgba(255,255,255,0.1); box-shadow: inset 0 0 5px rgba(255,255,255,0.05); }
        .custom-ratings-grid { display: grid; grid-template-columns: 1fr 80px 80px; gap: 0; }
        .custom-ratings-grid-header, .custom-ratings-grid-item { padding: 10px 15px; text-align: center; font-weight: bold; font-size: 0.95em; display: flex; align-items: center; justify-content: center; border-bottom: 1px solid var(--spl-border-light); box-sizing: border-box; }
        body.dark-mode .custom-ratings-grid-header, body.dark-mode .custom-ratings-grid-item { border-bottom-color: rgba(255,255,255,0.1); }
        .custom-ratings-grid-header { background-color: var(--spl-table-header-bg); color: var(--spl-text-dark); }
        body.dark-mode .custom-ratings-grid-header { background-color: var(--spl-table-header-bg); color: var(--spl-text-dark); }
        .custom-ratings-grid-item { background-color: var(--spl-container-bg); color: var(--spl-text-dark); }
        body.dark-mode .custom-ratings-grid-item { background-color: var(--spl-container-bg); color: var(--spl-text-dark); }
        .custom-ratings-grid-item:nth-last-child(-n + 3) { border-bottom: none; }
        .custom-ratings-grid-item select { width: 70px; padding: 5px; border: 1px solid var(--spl-border-light); border-radius: 4px; text-align: center; font-size: 0.9em; background-color: var(--spl-table-bg); color: var(--spl-text-dark); appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2C197.3L159.9%2C69.8c-2.9-2.9-6.9-4.7-11.1-4.7s-8.2%2C1.8-11.1%2C4.7L5.4%2C197.3c-3%2C3-4.7%2C6.9-4.7%2C11.1c0%2C4.2%2C1.7%2C8.2%2C4.7%2C11.2l21.4%2C21.4c2.9%2C2.9%2C6.9%2C4.7%2C11.1%2C4.7s8.2-1.8%2C11.1-4.7l115.5-115.5l115.5%2C115.5c2.9%2C2.9%2C6.9%2C4.7%2C11.1%2C4.7s8.2-1.8%2C11.1-4.7l21.4-21.4c3-3%2C4.7-6.9%2C4.7-11.2C291.7%2C204.2%2C290%2C200.3%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 5px center; background-size: 12px; padding-right: 25px; }
        .custom-ratings-grid-item select:focus { outline: none; border-color: var(--spl-primary-accent); box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); }
        body.dark-mode .custom-ratings-grid-item select { background-color: var(--spl-table-bg); color: var(--spl-text-dark); border-color: var(--spl-border-light); background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2C197.3L159.9%2C69.8c-2.9-2.9-6.9-4.7-11.1-4.7s-8.2%2C1.8-11.1%2C4.7L5.4%2C197.3c-3%2C3-4.7%2C6.9-4.7%2C11.1c0%2C4.2%2C1.7%2C8.2%2C4.7%2C11.2l21.4%2C21.4c2.9%2C2.9%2C6.9%2C4.7%2C11.1%2C4.7s8.2-1.8%2C11.1-4.7l115.5-115.5l115.5%2C115.5c2.9%2C2.9%2C6.9%2C4.7%2C11.1%2C4.7s8.2-1.8%2C11.1-4.7l21.4-21.4c3-3%2C4.7-6.9%2C4.7-11.2C291.7%2C204.2%2C290%2C200.3%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E'); }

        /* Main FDR & Customize Ratings Buttons */
        .control-room-buttons { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; }
        .control-room-buttons button { display: block; background-color: var(--spl-primary-accent); color: white; padding: 15px 30px; border: none; border-radius: 8px; font-size: 1.2em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2); max-width: fit-content; }
        .control-room-buttons button:hover { background-color: #0056b3; transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 123, 255, 0.3); }
        body.dark-mode .control-room-buttons button { background-color: #007bff; }
        body.dark-mode .control-room-buttons button:hover { background-color: #0056b3; }

        #fdrSystemsContainer, #teamsToTargetContainer, #transferPlannerContainer { display: none; flex-direction: column; align-items: center; gap: 15px; margin-top: 20px; padding: 20px; border-radius: 12px; background-color: var(--spl-container-bg); box-shadow: 0 4px 8px var(--spl-shadow); width: 100%; max-width: 1200px; box-sizing: border-box; margin-left: auto; margin-right: auto; }
        #fdrSystemsContainer p, #teamsToTargetContainer p, #transferPlannerContainer p { text-align: center; font-size: 1.1em; color: var(--spl-text-dark); margin-bottom: 10px; }

        /* Welcome Dashboard content */
        #initialLoggedInDashboardContent { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px; text-align: center; padding: 20px; color: var(--spl-text-dark); }
        #initialLoggedInDashboardContent h2 { color: var(--spl-primary-accent); }

        /* CSS Grid Specific Styles for the Schedule */
        .schedule-grid-container { width: 100%; overflow-x: auto; margin-top: 15px; border: 1px solid var(--spl-border-light); border-radius: 8px; box-shadow: inset 0 0 5px rgba(0,0,0,0.05); background-color: var(--spl-container-bg); font-size: 0.9em; transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; }
        body.dark-mode .schedule-grid-container { border-color: rgba(255,255,255,0.1); box-shadow: inset 0 0 5px rgba(255,255,255,0.05); }
        .schedule-grid { display: grid; grid-auto-rows: minmax(40px, auto); min-width: 600px; }
        .grid-header-cell { background-color: var(--spl-table-header-bg); color: var(--spl-text-dark); font-weight: bold; padding: 8px 12px; text-align: center; border: 1px solid var(--spl-border-light); white-space: nowrap; display: flex; align-items: center; justify-content: center; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
        body.dark-mode .grid-header-cell { background-color: var(--spl-table-header-bg); color: var(--spl-text-dark); }
        .grid-row-team-cell { background-color: var(--spl-table-bg); color: var(--spl-text-dark); font-weight: bold; padding: 8px 12px; text-align: center; border: 1px solid var(--spl-border-light); white-space: nowrap; display: flex; align-items: center; justify-content: center; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
        body.dark-mode .grid-row-team-cell { background-color: var(--spl-table-row-even); color: var(--spl-text-dark); }
        .grid-fixture-cell { padding: 5px 8px; border: 1px solid var(--spl-border-light); text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; min-height: 40px; box-sizing: border-box; transition: background-color 0.3s ease, border-color 0.3s ease; background-color: var(--spl-container-bg); color: var(--spl-text-dark); }
        body.dark-mode .grid-fixture-cell { border-color: rgba(255,255,255,0.1); background-color: var(--spl-container-bg); color: var(--spl-text-dark); }
        .grid-fixture-cell.fdr-1 { background-color: #00B050; color: white; } .grid-fixture-cell.fdr-2 { background-color: #92D050; color: black; }
        .grid-fixture-cell.fdr-3 { background-color: #FFFF00; color: black; } .grid-fixture-cell.fdr-4 { background-color: #FFC000; color: black; }
        .grid-fixture-cell.fdr-5 { background-color: #FF0000; color: white; } .grid-fixture-cell.fdr-6 { background-color: #C00000; color: white; }
        .grid-fixture-cell.fdr-7 { background-color: #800000; color: white; }
        .grid-fixture-cell.fdr-na { background-color: #ccc; color: #666; }
        body.dark-mode .grid-fixture-cell.fdr-1 { background-color: #008037; } body.dark-mode .grid-fixture-cell.fdr-2 { background-color: #6B9F3B; }
        body.dark-mode .grid-fixture-cell.fdr-3 { background-color: #B3B300; } body.dark-mode .grid-fixture-cell.fdr-4 { background-color: #B38600; }
        body.dark-mode .grid-fixture-cell.fdr-5 { background-color: #B30000; } body.dark-mode .grid-fixture-cell.fdr-6 { background-color: #800000; }
        body.dark-mode .grid-fixture-cell.fdr-7 { background-color: #530000; }
        body.dark-mode .grid-fixture-cell.fdr-na { background-color: #555; color: #aaa; }
        .fixture-item-display { display: flex; align-items: center; justify-content: center; gap: 5px; padding: 2px 5px; border-radius: 3px; font-size: 0.85em; white-space: nowrap; font-weight: bold; width: 100%; box-sizing: border-box; }
        @media (max-width: 768px) { .schedule-grid { grid-template-columns: minmax(80px, 1fr) repeat(auto-fit, minmax(60px, 1fr)); min-width: unset; } .grid-header-cell, .grid-row-team-cell, .grid-fixture-cell { padding: 6px 8px; font-size: 0.8em; } .fixture-item-display { font-size: 0.75em; padding: 1px 3px; } }
        @media (max-width: 480px) { .schedule-grid { grid-template-columns: minmax(70px, 1fr) repeat(auto-fit, minmax(50px, 1fr)); } .grid-header-cell, .grid-row-team-cell, .grid-fixture-cell { padding: 5px 6px; font-size: 0.75em; } .fixture-item-display { font-size: 0.7em; gap: 3px; } }

        /* Teams To Target specific styles */
        .teams-to-target-grid .grid-header-cell.fdr-total-header { background-color: var(--spl-primary-accent); color: white; }
        body.dark-mode .teams-to-target-grid .grid-header-cell.fdr-total-header { background-color: #007bff; }
        .teams-to-target-grid .grid-fdr-total-cell { background-color: var(--spl-table-header-bg); color: var(--spl-text-dark); font-weight: bold; }
        body.dark-mode .teams-to-target-grid .grid-fdr-total-cell { background-color: var(--spl-table-header-bg); color: var(--spl-text-dark); }


        /* Tuning section styles */
        .tuning-section { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; padding: 15px; border-radius: 8px; max-width: 400px; margin-left: auto; margin-right: auto; margin-bottom: 10px; }
        .tuning-section label { font-weight: bold; color: var(--spl-text-dark); }
        .tuning-section input[type="range"] { width: 100%; -webkit-appearance: none; height: 8px; border-radius: 5px; background: var(--spl-border-light); outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; }
        .tuning-section input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--spl-primary-accent); cursor: pointer; }
        .tuning-section input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: var(--spl-primary-accent); cursor: pointer; }
        .tuning-option { display: flex; align-items: center; gap: 10px; }
        .tuning-value { font-weight: bold; color: var(--spl-primary-accent); }
        body.dark-mode .tuning-section label { color: var(--spl-text-dark); }
        body.dark-mode .tuning-section input[type="range"] { background: #555; }
        body.dark-mode .tuning-section input[type="range"]::-webkit-slider-thumb { background: #007bff; }
        body.dark-mode .tuning-section input[type="range"]::-moz-range-thumb { background: #007bff; }
        body.dark-mode .tuning-value { color: #FFD700; }

        /* Specific margin adjustments for compactness */
        #showCustomRatingsGridButton { margin-top: 10px; margin-bottom: 10px; }
        #saveCustomFDRRatingsButton { margin-top: 10px; margin-bottom: 5px; } /* Reduced to bring message closer */
        #customRatingsMessageBox { margin-top: 5px; margin-bottom: 15px; } /* Adjust for tight placement */
        #saveFDRSystemMessage { margin-top: 5px; margin-bottom: 10px; } /* For "FDR System Saved" message */

        /* Chosen FDR System Display */
        .chosen-fdr-system-display { text-align: center; font-size: 1.1em; font-weight: bold; color: var(--spl-primary-accent); margin-bottom: 15px; display: none; }
        body.dark-mode .chosen-fdr-system-display { color: #FFD700; }

        /* Transfer Planner Specific Styles */
        #transferPlannerContainer {
            display: grid;
            grid-template-columns: 2fr 1fr; /* Pitch/Bench on left, Player List/Summary on right */
            gap: 20px;
            padding: 20px;
            min-height: 700px;
            align-items: start; /* Align items to the start of their grid areas */
            max-width: 1400px; /* Wider for planner */
        }
        @media (max-width: 1024px) {
            #transferPlannerContainer {
                grid-template-columns: 1fr; /* Stack vertically on smaller screens */
            }
        }

        .pitch-bench-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 8px var(--spl-shadow);
            position: relative; /* For background image */
        }

        .pitch {
            background-image: url('https://placehold.co/800x450/008000/ffffff?text=Football+Pitch'); /* Placeholder pitch image */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            padding: 10px;
            display: grid;
            grid-template-areas:
                "gk-area gk-area gk-area gk-area"
                "def-area def-area def-area def-area"
                "mid-area mid-area mid-area mid-area"
                "fwd-area fwd-area fwd-area fwd-area"; /* Grid areas for positions */
            grid-template-columns: repeat(4, 1fr); /* Adjust as needed for specific layouts */
            grid-template-rows: auto auto auto auto; /* Adjust based on content */
            height: 450px; /* Fixed height for pitch for now */
            position: relative;
        }
        .bench {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.1); /* Slightly transparent background */
            border-radius: 8px;
            min-height: 100px;
        }

        .player-slot {
            border: 2px dashed var(--spl-border-light);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5px;
            font-size: 0.8em;
            color: var(--spl-text-dark);
            background-color: rgba(255,255,255,0.1); /* Slightly transparent background */
            min-width: 80px;
            min-height: 100px;
            position: relative; /* For player card positioning */
            overflow: hidden; /* Hide overflow if player card is larger */
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        body.dark-mode .player-slot {
            border-color: rgba(255,255,255,0.2);
            background-color: rgba(255,255,255,0.05);
        }

        .player-slot.drag-over {
            border-color: var(--spl-primary-accent);
            background-color: rgba(0, 123, 255, 0.2);
        }

        /* Pitch specific slot positioning */
        .pitch-gk-slots { grid-area: gk-area; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .pitch-def-slots { grid-area: def-area; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .pitch-mid-slots { grid-area: mid-area; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .pitch-fwd-slots { grid-area: fwd-area; display: flex; justify-content: center; align-items: center; gap: 5px; }

        .player-card {
            width: 100%;
            height: 100%;
            background-color: var(--spl-table-bg);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 5px;
            cursor: grab;
            position: absolute; /* To fit within slot */
            top: 0; left: 0;
            box-sizing: border-box;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        body.dark-mode .player-card {
            background-color: var(--spl-table-row-even);
        }

        .player-card img.player-image {
            width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-bottom: 5px;
            border: 2px solid var(--spl-primary-accent);
        }
        .player-card img.team-logo {
            width: 20px; height: 20px; object-fit: contain; margin-left: 5px;
        }
        .player-card .player-name { font-weight: bold; font-size: 0.9em; color: var(--spl-text-dark); }
        .player-card .player-details { font-size: 0.75em; color: var(--spl-text-medium); display: flex; align-items: center; margin-top: 2px;}
        .player-card .player-price { font-weight: bold; color: var(--spl-accent-green); font-size: 0.85em; margin-top: 2px; }
        .player-card .player-opponent { font-size: 0.7em; color: var(--spl-text-medium); margin-top: 2px; }
        .player-card .fdr-value-display { 
            display: inline-block; 
            padding: 2px 5px; 
            border-radius: 4px; 
            font-size: 0.65em; 
            font-weight: bold; 
            color: white; 
            margin-left: 5px;
        }
        /* FDR colors for player card opponent display */
        .fdr-value-display.fdr-1 { background-color: #00B050; } .fdr-value-display.fdr-2 { background-color: #92D050; color: black; }
        .fdr-value-display.fdr-3 { background-color: #FFFF00; color: black; } .fdr-value-display.fdr-4 { background-color: #FFC000; color: black; }
        .fdr-value-display.fdr-5 { background-color: #FF0000; } .fdr-value-display.fdr-6 { background-color: #C00000; }
        .fdr-value-display.fdr-7 { background-color: #800000; } .fdr-value-display.fdr-na { background-color: #ccc; color: #666; }
        body.dark-mode .fdr-value-display.fdr-2, body.dark-mode .fdr-value-display.fdr-3, body.dark-mode .fdr-value-display.fdr-4 { color: black; }
        body.dark-mode .fdr-value-display.fdr-1 { background-color: #008037; } body.dark-mode .fdr-value-display.fdr-2 { background-color: #6B9F3B; }
        body.dark-mode .fdr-value-display.fdr-3 { background-color: #B3B300; } body.dark-mode .fdr-value-display.fdr-4 { background-color: #B38600; }
        body.dark-mode .fdr-value-display.fdr-5 { background-color: #B30000; } body.dark-mode .fdr-value-display.fdr-6 { background-color: #800000; }
        body.dark-mode .fdr-value-display.fdr-7 { background-color: #530000; }
        body.dark-mode .fdr-value-display.fdr-na { background-color: #555; color: #aaa; }


        .player-list-sidebar {
            background-color: var(--spl-container-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 8px var(--spl-shadow);
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 700px; /* Fixed height for scrollability */
            overflow-y: auto;
        }
        .player-list-sidebar .player-card {
            position: relative; /* Override absolute for list */
            width: auto; height: auto;
            padding: 10px;
            margin-bottom: 5px;
            flex-direction: row;
            justify-content: flex-start;
            gap: 10px;
        }
        .player-list-sidebar .player-card img.player-image {
            width: 40px; height: 40px; min-width: 40px;
        }
        .player-list-sidebar .player-card .player-info {
            display: flex; flex-direction: column; align-items: flex-start;
        }
        .player-list-sidebar .player-card .player-name { font-size: 1em; }
        .player-list-sidebar .player-card .player-details { font-size: 0.8em; }
        .player-list-sidebar .player-card .player-price { font-size: 0.9em; }


        .transfer-controls {
            grid-column: 1 / -1; /* Span across both columns */
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .transfer-controls button {
            background-color: var(--spl-primary-accent);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .transfer-controls button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }
        .transfer-controls .info-display {
            background-color: var(--spl-table-bg);
            padding: 10px 15px;
            border-radius: 8px;
            color: var(--spl-text-dark);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        body.dark-mode .transfer-controls .info-display {
            background-color: var(--spl-table-row-even);
        }

        /* Player position specific grid areas for pitch */
        .pitch-gk-slots { grid-area: gk-area; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .pitch-def-slots { grid-area: def-area; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .pitch-mid-slots { grid-area: mid-area; display: flex; justify-content: center; align-items: center; gap: 5px; }
        .pitch-fwd-slots { grid-area: fwd-area; display: flex; justify-content: center; align-items: center; gap: 5px; }

        /* Player slot icons */
        .player-slot .player-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }
        .player-slot .player-actions .action-icon {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .player-slot .player-actions .action-icon:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
        .player-slot .player-actions .action-icon.remove-player {
            background-color: #dc3545; /* Red for remove */
        }
        .player-slot .player-actions .action-icon.remove-player:hover {
            background-color: #c82333;
        }
        .player-slot .player-actions .action-icon.move-player {
            background-color: #007bff; /* Blue for move */
        }
        .player-slot .player-actions .action-icon.move-player:hover {
            background-color: #0056b3;
        }

        /* Player filter buttons */
        #playerFilters {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        #playerFilters button {
            background-color: var(--spl-table-header-bg);
            color: var(--spl-text-dark);
            border: 1px solid var(--spl-border-light);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        #playerFilters button:hover {
            background-color: var(--spl-table-row-hover);
        }
        #playerFilters button.active {
            background-color: var(--spl-primary-accent);
            color: white;
            border-color: var(--spl-primary-accent);
        }
        body.dark-mode #playerFilters button {
            background-color: var(--spl-table-header-bg);
            color: var(--spl-text-dark);
            border-color: rgba(255,255,255,0.2);
        }
        body.dark-mode #playerFilters button.active {
            background-color: #007bff;
            border-color: #007bff;
        }

    </style>
</head>
<body>
    <div id="logo-container">
        <img id="mainLogo" src="unnamed.jpg" alt="Fantasy SPL Data Center Logo">
    </div>

    <!-- Theme Switch -->
    <div class="theme-switch-wrapper">
        <label class="theme-switch" for="darkModeToggle">
            <input type="checkbox" id="darkModeToggle" />
            <span class="slider round"></span>
        </label>
        <em class="theme-label">Dark Mode</em>
    </div>

    <div class="container">
        <h1>Control Room V2</h1> 

        <!-- Authentication Section -->
        <div id="authSection">
            <div id="loginForm"> 
                <h2>Login</h2>
                <input type="email" id="loginEmail" placeholder="Email Address">
                <input type="password" id="loginPassword" placeholder="Password">
                <button id="loginButton">Login</button>
                <p>Don't have an account? <a href="#" id="showSignupLink">Sign Up</a></p>
            </div>

            <div id="signupForm" style="display: none;"> 
                <h2>Sign Up</h2>
                <input type="email" id="signupEmail" placeholder="Email Address">
                <input type="password" id="signupPassword" placeholder="Password">
                <input type="password" id="signupConfirmPassword" placeholder="Confirm Password">
                <input type="text" id="signupManagerId" placeholder="Your SPL Manager ID" oninput="this.value = convertArabicToWesternNumerals(this.value)">
                <button id="signupButton">Sign Up</button>
                <p>Already have an account? <a href="#" id="showLoginLink">Login</a></p>

                <div id="instructionsBox" class="instructions" style="display: none;"> 
                    <h3>How to get your Manager ID:</h3>
                    <ol>
                        <li>Go to <a href="https://fantasy.spl.com.sa/" target="_blank">https://fantasy.spl.com.sa/</a> from your browser (SPL app does not work to get your ID).</li>
                        <li>Login with your credentials.</li>
                        <li>Click on "Points" in the top menu.</li>
                        <li>Check the address bar and look for the numbers after the word "/entry/". Copy that - it is your ID number.</li>
                    </ol>
                </div>
            </div>
            
            <div id="authMessageBox" class="message-box"></div> 
        </div>

        <!-- Logged In Content -->
        <div id="loggedInContent" class="container" style="display: none;">
            <i class="fas fa-bars" id="menuToggle"></i>

            <hr style="margin: 20px 0; border-color: var(--spl-border-light);">

            <!-- Sidebar Menu -->
            <nav id="sidebarMenu">
                <div id="sidebarHeader">
                    <span id="sidebarTeamName">Your Team</span>
                </div>
                <a href="#" id="menuMyControlRoom">My Control Room</a>
                <a href="#" id="menuAdminDashboard" style="display: none;">Admin Dashboard</a>
                <p id="sidebarManagerIdText">Manager ID: <span id="displayLoggedInManagerId"></span></p>
                <button id="logoutButton" class="red-button">Logout</button>
            </nav>
            <div id="overlay"></div>

            <!-- Content areas -->
            <div id="initialLoggedInDashboardContent" style="display: none;">
                <h2>Welcome to Your Control Room!</h2>
                <p>Select an option from the menu to get started.</p>
            </div>

            <div id="analyzerReportContent" style="display: none;">
                <p style="text-align: center; color: var(--spl-text-medium); margin-top: 50px;">
                    The "Analyze My Team" feature has been removed.
                </p>
            </div>

            <!-- My Control Room Content -->
            <div id="myControlRoomContent" style="display: none;">
                <h2>My Control Room</h2>
                
                <div class="control-room-buttons">
                    <button id="showFDRButton">FDR</button>
                    <button id="showTeamsToTargetButton">Teams To Target</button>
                    <button id="showTransferPlannerButton">Transfer Planner</button>
                </div>

                <!-- FDR Systems Container -->
                <div id="fdrSystemsContainer">
                    <p id="controlRoomMessageBox" class="message-box" style="display: none;"></p>
                    <p id="saveFDRSystemMessage" class="message-box success" style="display: none;"></p>
                    <p class="chosen-fdr-system-display" id="chosenFDRSystemDisplayFDR"></p>
                    <p>Please Choose FDR System</p>

                    <div class="fdr-system-selection">
                        <label>
                            <input type="radio" name="fdrSystem" value="overall" id="radioOverallFDR"> Overall FDR
                        </label>
                        <label>
                            <input type="radio" name="fdrSystem" value="homeAway" id="radioHomeAwayFDR"> Home/Away FDR
                        </label>
                        <label>
                            <input type="radio" name="fdrSystem" value="customized" id="radioCustomizedFDR"> Customized FDR
                        </label>
                        <button id="saveFDRSystemButton">Save as My FDR System</button>
                    </div>

                    <h5 class="fdr-section-title" style="margin-top: 0;">Fixture Difficulty Scale</h5>
                    <div id="fdrScaleDisplay" class="fdr-scale"></div>

                    <div class="tuning-section">
                        <div class="tuning-option">
                            <label for="roundsToShow">Rounds: <span id="roundsToShowValue">5</span></label>
                            <input type="range" id="roundsToShow" min="3" max="10" value="5">
                        </div>
                    </div>

                    <!-- NEW: Customize Ratings Button (for Customized FDR only) -->
                    <button id="showCustomRatingsGridButton" style="display: none;">Customize Ratings</button>
                    
                    <!-- FDR Display for My Control Room -->
                    <div id="myControlRoomFDRDisplay" style="display: none;">
                        <div id="overallFDRSectionControlRoom" style="display: none;">
                            <h5 class="fdr-section-title">Overall Fixture Difficulty Schedule</h5>
                            <div class="schedule-grid-container">
                                <div class="schedule-grid" id="overallScheduleGrid"></div>
                            </div>
                        </div>

                        <div id="homeAwayFDRSectionControlRoom" style="display: none;">
                            <h5 class="fdr-section-title">Home/Away Fixture Difficulty Schedule</h5>
                            <div class="schedule-grid-container">
                                <div class="schedule-grid" id="homeAwayScheduleGrid"></div>
                            </div>
                        </div>

                        <div id="customizedFDRSectionControlRoom" style="display: none;">
                            <h5 class="fdr-section-title">Customized Fixture Difficulty Schedule</h5>
                            <!-- Custom Ratings Input Grid Container -->
                            <div id="customRatingsInputGridContainer" class="custom-ratings-input-grid-container">
                                <div class="custom-ratings-grid" id="customRatingsGrid"></div>
                            </div>
                            <!-- Save Custom Ratings Button -->
                            <button id="saveCustomFDRRatingsButton" class="mt-4" style="display: none;">Save Custom Ratings</button>
                            <!-- Message box for custom ratings validation - MOVED HERE -->
                            <p id="customRatingsMessageBox" class="message-box" style="display: none;"></p>
                            <!-- Schedule grid for Customized FDR -->
                            <div class="schedule-grid-container">
                                <div class="schedule-grid" id="customizedScheduleGrid"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Teams To Target Container -->
                <div id="teamsToTargetContainer" style="display: none;">
                    <p class="chosen-fdr-system-display" id="chosenFDRSystemDisplayTeamsToTarget"></p>
                    <h3 class="fdr-section-title">Teams To Target (Easiest Fixtures)</h3>
                    <p>Teams are ranked by total FDR over the selected rounds (lowest total = easiest run).</p>
                    <div class="tuning-section">
                        <div class="tuning-option">
                            <label for="roundsToShowTeamsToTarget">Rounds: <span id="roundsToShowValueTeamsToTarget">5</span></label>
                            <input type="range" id="roundsToShowTeamsToTarget" min="3" max="10" value="5">
                        </div>
                    </div>
                    <div class="schedule-grid-container">
                        <div class="schedule-grid teams-to-target-grid" id="teamsToTargetScheduleGrid"></div>
                    </div>
                </div>

                <!-- Transfer Planner Container -->
                <div id="transferPlannerContainer" style="display: none;">
                    <h3 class="fdr-section-title">Transfer Planner</h3>
                    <p id="transferPlannerMessage" class="message-box info" style="display: none;"></p>
                    
                    <div class="transfer-controls">
                        <button id="prevRoundButton">Previous Round</button>
                        <span class="info-display">Planning Round: <span id="currentPlanningRoundDisplay">2</span></span>
                        <span class="info-display">Free Transfers: <span id="freeTransfersDisplay">1</span></span>
                        <span class="info-display">Points Hit: <span id="pointsHitDisplay">0</span></span>
                        <span class="info-display">Funds: <span id="fundsDisplay">0.0m</span></span>
                        <button id="nextRoundButton">Next Round</button>
                        <button id="savePlanButton">Save Plan</button>
                        <button id="loadPlanButton">Load Plan</button>
                        <button id="resetPlan">Reset Plan</button>
                    </div>

                    <div class="pitch-bench-area">
                        <div class="pitch" id="pitchArea">
                            <!-- GK slots (1) -->
                            <div class="pitch-gk-slots">
                                <div class="player-slot" data-position="GKP" data-slot-id="1" data-slot-type="pitch"></div>
                            </div>
                            <!-- DEF slots (4 for default display) -->
                            <div class="pitch-def-slots">
                                <div class="player-slot" data-position="DEF" data-slot-id="2" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="DEF" data-slot-id="3" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="DEF" data-slot-id="4" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="DEF" data-slot-id="5" data-slot-type="pitch"></div>
                            </div>
                            <!-- MID slots (4 for default display) -->
                            <div class="pitch-mid-slots">
                                <div class="player-slot" data-position="MID" data-slot-id="6" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="MID" data-slot-id="7" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="MID" data-slot-id="8" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="MID" data-slot-id="9" data-slot-type="pitch"></div>
                            </div>
                            <!-- FWD slots (2 for default display) -->
                            <div class="pitch-fwd-slots">
                                <div class="player-slot" data-position="FWD" data-slot-id="10" data-slot-type="pitch"></div>
                                <div class="player-slot" data-position="FWD" data-slot-id="11" data-slot-type="pitch"></div>
                            </div>
                        </div>
                        <div class="bench" id="benchArea">
                            <!-- Bench slots (4) -->
                            <div class="player-slot" data-position="BENCH" data-slot-id="12" data-slot-type="bench"></div>
                            <div class="player-slot" data-position="BENCH" data-slot-id="13" data-slot-type="bench"></div>
                            <div class="player-slot" data-position="BENCH" data-slot-id="14" data-slot-type="bench"></div>
                            <div class="player-slot" data-position="BENCH" data-slot-id="15" data-slot-type="bench"></div>
                        </div>
                    </div>

                    <div class="player-list-sidebar">
                        <h4>Available Players</h4>
                        <input type="text" id="playerSearchInput" placeholder="Search players...">
                        <div id="playerFilters">
                            <button data-filter="GKP">GK</button>
                            <button data-filter="DEF">DEF</button>
                            <button data-filter="MID">MID</button>
                            <button data-filter="FWD">FWD</button>
                            <button data-filter="ALL" class="active">All</button>
                        </div>
                        <div id="playerList" style="flex-grow: 1; overflow-y: auto;">
                            <!-- Player cards will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Admin Dashboard Content -->
            <div id="adminDashboardContent" style="display: none;"> 
                <h2>Admin Dashboard</h2>
                <div class="admin-dashboard-nav-buttons">
                    <button id="adminUsersButton">Users</button>
                    <button id="adminDataButton">Data</button>
                </div>
                <div class="admin-search-section" style="display: none;">
                    <input type="text" id="adminSearchInput" placeholder="Search by Email, SPL ID, or UID">
                    <button id="adminSearchButton">Search User</button>
                </div>

                <div id="adminSearchResults" class="admin-edit-section" style="display: none;">
                    <h3>User Found:</h3>
                    <p>User ID: <strong id="adminUserUid">N/A</strong></p>
                    <p>Current Email: <input type="email" id="adminEditEmail"></p>
                    <p>Current SPL Manager ID: <input type="text" id="adminEditSplManagerId" oninput="this.value = convertArabicToWesternNumerals(this.value)"></p>
                    <button id="adminUpdateUserButton">Update User</button>
                </div>

                <div id="adminMessage" class="message-box" style="display: none;"></div>

                <!-- Data Upload Section (Admin Dashboard) -->
                <div id="dataUploadSection" style="display: none;">
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Upload League Tables</h3>
                    <div class="mb-3 input-group">
                        <label for="rankingTypeSelect" class="block text-gray-700 text-sm font-bold mb-2">
                            Select Ranking Type for Upload:
                        </label>
                        <select
                            id="rankingTypeSelect"
                            class="shadow border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline admin-input"
                        >
                            <option value="overall">Overall Ranking</option>
                            <option value="home">Home Ranking</option>
                            <option value="away">Away Ranking</option>
                        </select>
                    </div>
                    <label class="upload-button-label">
                        Upload Excel File
                        <input
                            type="file"
                            accept=".xlsx, .xls"
                            id="excelFileUploadInput"
                            class="hidden"
                        />
                    </label>
                    <p id="excelUploadMessage" class="mt-2 text-sm text-center message-box" style="display: none;"></p>

                    <!-- API Fetch Status Messages -->
                    <h3 class="text-xl font-semibold text-gray-700 mb-3 mt-8">API Data Status</h3>
                    <p id="apiTeamNamesStatus" class="mt-2 text-sm text-center message-box" style="display: none;"></p>
                    <p id="apiScheduleStatus" class="mt-2 text-sm text-center message-box" style="display: none;"></p>

                    <!-- Display Current Rankings (Admin) -->
                    <div id="currentRankingsDisplayAdmin" class="mt-8">
                        <h4 class="text-lg font-semibold text-gray-700 mb-3 text-center">Current Rankings Data</h4>
                        
                        <div id="overallFDRSectionAdmin" style="display: none;">
                            <h5 class="text-md font-semibold text-gray-600 mb-2 text-center">Overall Rankings</h5>
                            <div class="fdr-scale" id="overallFDRScaleAdmin"></div>
                            <div class="fdr-data-grid" id="overallFDRGridAdmin"></div>
                        </div>

                        <div id="homeFDRSectionAdmin" style="display: none; margin-top: 30px;">
                            <h5 class="text-md font-semibold text-gray-600 mb-2 text-center">Home Rankings</h5>
                            <div class="fdr-scale" id="homeFDRScaleAdmin"></div>
                            <div class="fdr-single-column-grid" id="homeFDRGridAdmin"></div>
                        </div>

                        <div id="awayFDRSectionAdmin" style="display: none; margin-top: 30px;">
                            <h5 class="text-md font-semibold text-gray-600 mb-2 text-center">Away Rankings</h5>
                            <div class="fdr-scale" id="awayFDRScaleAdmin"></div>
                            <div class="fdr-single-column-grid" id="awayFDRGridAdmin"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, sendEmailVerification, onAuthStateChanged, signOut, reload } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, serverTimestamp, updateDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // DOM Element References
        const mainLogo = document.getElementById('mainLogo');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const authSection = document.getElementById('authSection');
        const loginForm = document.getElementById('loginForm');
        const loginEmailInput = document.getElementById('loginEmail');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginButton = document.getElementById('loginButton');
        const showSignupLink = document.getElementById('showSignupLink');
        const signupForm = document.getElementById('signupForm');
        const signupEmailInput = document.getElementById('signupEmail');
        const signupPasswordInput = document.getElementById('signupPassword');
        const signupConfirmPasswordInput = document.getElementById('signupConfirmPassword');
        const signupManagerIdInput = document.getElementById('signupManagerId');
        const signupButton = document.getElementById('signupButton');
        const showLoginLink = document.getElementById('showLoginLink');
        const instructionsBox = document.getElementById('instructionsBox');
        const authMessageBox = document.getElementById('authMessageBox');
        const loggedInContent = document.getElementById('loggedInContent');
        const menuToggle = document.getElementById('menuToggle');
        const sidebarMenu = document.getElementById('sidebarMenu');
        const overlay = document.getElementById('overlay');
        const sidebarTeamName = document.getElementById('sidebarTeamName');
        const menuMyControlRoom = document.getElementById('menuMyControlRoom');
        const menuAdminDashboard = document.getElementById('menuAdminDashboard');
        const displayLoggedInManagerId = document.getElementById('displayLoggedInManagerId');
        const logoutButton = document.getElementById('logoutButton');
        const initialLoggedInDashboardContent = document.getElementById('initialLoggedInDashboardContent');
        const analyzerReportContent = document.getElementById('analyzerReportContent');
        const myControlRoomContent = document.getElementById('myControlRoomContent');
        const showFDRButton = document.getElementById('showFDRButton');
        const showTeamsToTargetButton = document.getElementById('showTeamsToTargetButton');
        const showTransferPlannerButton = document.getElementById('showTransferPlannerButton');
        const fdrSystemsContainer = document.getElementById('fdrSystemsContainer');
        const controlRoomMessageBox = document.getElementById('controlRoomMessageBox');
        const saveFDRSystemMessage = document.getElementById('saveFDRSystemMessage');
        const chosenFDRSystemDisplayFDR = document.getElementById('chosenFDRSystemDisplayFDR');
        const radioOverallFDR = document.getElementById('radioOverallFDR');
        const radioHomeAwayFDR = document.getElementById('radioHomeAwayFDR');
        const radioCustomizedFDR = document.getElementById('radioCustomizedFDR');
        const saveFDRSystemButton = document.getElementById('saveFDRSystemButton');
        const fdrScaleDisplay = document.getElementById('fdrScaleDisplay');
        const roundsToShowSlider = document.getElementById('roundsToShow');
        const roundsToShowValueSpan = document.getElementById('roundsToShowValue');
        const showCustomRatingsGridButton = document.getElementById('showCustomRatingsGridButton');
        const myControlRoomFDRDisplay = document.getElementById('myControlRoomFDRDisplay');
        const overallFDRSectionControlRoom = document.getElementById('overallFDRSectionControlRoom');
        const overallScheduleGrid = document.getElementById('overallScheduleGrid');
        const homeAwayFDRSectionControlRoom = document.getElementById('homeAwayFDRSectionControlRoom');
        const homeAwayScheduleGrid = document.getElementById('homeAwayScheduleGrid');
        const customizedFDRSectionControlRoom = document.getElementById('customizedFDRSectionControlRoom');
        const customRatingsInputGridContainer = document.getElementById('customRatingsInputGridContainer');
        const customRatingsGrid = document.getElementById('customRatingsGrid');
        const saveCustomFDRRatingsButton = document.getElementById('saveCustomFDRRatingsButton');
        const customRatingsMessageBox = document.getElementById('customRatingsMessageBox');
        const customizedScheduleGrid = document.getElementById('customizedScheduleGrid');
        const teamsToTargetContainer = document.getElementById('teamsToTargetContainer');
        const chosenFDRSystemDisplayTeamsToTarget = document.getElementById('chosenFDRSystemDisplayTeamsToTarget');
        const roundsToShowTeamsToTargetSlider = document.getElementById('roundsToShowTeamsToTarget');
        const roundsToShowValueTeamsToTargetSpan = document.getElementById('roundsToShowValueTeamsToTarget');
        const teamsToTargetScheduleGrid = document.getElementById('teamsToTargetScheduleGrid');
        const transferPlannerContainer = document.getElementById('transferPlannerContainer');
        const transferPlannerMessage = document.getElementById('transferPlannerMessage');
        const prevRoundButton = document.getElementById('prevRoundButton');
        const currentPlanningRoundDisplay = document.getElementById('currentPlanningRoundDisplay');
        const freeTransfersDisplay = document.getElementById('freeTransfersDisplay');
        const pointsHitDisplay = document.getElementById('pointsHitDisplay');
        const fundsDisplay = document.getElementById('fundsDisplay');
        const nextRoundButton = document.getElementById('nextRoundButton');
        const savePlanButton = document.getElementById('savePlanButton');
        const loadPlanButton = document.getElementById('loadPlanButton');
        const resetPlanButton = document.getElementById('resetPlan'); // Corrected ID for reset button
        const pitchArea = document.getElementById('pitchArea');
        const benchArea = document.getElementById('benchArea');
        const playerSearchInput = document.getElementById('playerSearchInput');
        const playerFilters = document.getElementById('playerFilters');
        const playerList = document.getElementById('playerList');
        const adminDashboardContent = document.getElementById('adminDashboardContent');
        const adminDashboardNavButtons = document.querySelector('.admin-dashboard-nav-buttons');
        const adminUsersButton = document.getElementById('adminUsersButton');
        const adminDataButton = document.getElementById('adminDataButton');
        const adminSearchSection = document.querySelector('.admin-search-section');
        const adminSearchInput = document.getElementById('adminSearchInput');
        const adminSearchButton = document.getElementById('adminSearchButton');
        const adminSearchResults = document.getElementById('adminSearchResults');
        const adminUserUidElem = document.getElementById('adminUserUid');
        const adminEditEmailInput = document.getElementById('adminEditEmail');
        const adminEditSplManagerIdInput = document.getElementById('adminEditSplManagerId');
        const adminUpdateUserButton = document.getElementById('adminUpdateUserButton');
        const adminMessage = document.getElementById('adminMessage');
        const dataUploadSection = document.getElementById('dataUploadSection');
        const rankingTypeSelect = document.getElementById('rankingTypeSelect');
        const excelFileUploadInput = document.getElementById('excelFileUploadInput');
        const excelUploadMessage = document.getElementById('excelUploadMessage');
        const apiTeamNamesStatus = document.getElementById('apiTeamNamesStatus');
        const apiScheduleStatus = document.getElementById('apiScheduleStatus');
        const currentRankingsDisplayAdmin = document.getElementById('currentRankingsDisplayAdmin');
        const overallFDRSectionAdmin = document.getElementById('overallFDRSectionAdmin');
        const overallFDRScaleAdmin = document.getElementById('overallFDRScaleAdmin');
        const overallFDRGridAdmin = document.getElementById('overallFDRGridAdmin');
        const homeFDRSectionAdmin = document.getElementById('homeFDRSectionAdmin');
        const homeFDRScaleAdmin = document.getElementById('homeFDRScaleAdmin');
        const homeFDRGridAdmin = document.getElementById('homeFDRGridAdmin');
        const awayFDRSectionAdmin = document.getElementById('awayFDRSectionAdmin');
        const awayFDRScaleAdmin = document.getElementById('awayFDRScaleAdmin');
        const awayFDRGridAdmin = document.getElementById('awayFDRGridAdmin');

        // Logo paths
        const lightModeLogoSrc = "unnamed.jpg";
        const darkModeLogoSrc = "unnamed.jpg"; // Assuming the same logo for dark mode, or provide a different one if available

        // Firebase Config (PLACEHOLDER FOR NETLIFY INJECTION)
        // IMPORTANT: In your Netlify environment, you would set these as environment variables
        // and inject them into the client-side code during build or runtime.
        const firebaseConfig = {
            apiKey: "{{FIREBASE_API_KEY}}", 
            authDomain: "{{FIREBASE_AUTH_DOMAIN}}",
            projectId: "{{FIREBASE_PROJECT_ID}}",
            storageBucket: "{{FIREBASE_STORAGE_BUCKET}}",
            messagingSenderId: "{{FIREBASE_MESSAGING_SENDER_ID}}",
            appId: "{{FIREBASE_APP_ID}}"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // API Endpoints (PLACEHOLDERS FOR NETLIFY INJECTION)
        // These should be configured in your Netlify functions or environment variables
        // and passed to the client-side.
        const API_BOOTSTRAP_STATIC = "{{API_BOOTSTRAP_STATIC}}";
        const API_FIXTURES_BASE = "{{API_FIXTURES_BASE}}";
        const API_MANAGER_HISTORY_BASE = '/.netlify/functions/fetch-spl-data?id='; 

        // Global Variables
        let isProcessingAuth = false; 
        let currentManagerId = null; 
        let isAdminUser = false; 
        let foundUserForAdminEdit = null; 
        let globalSplRankings = { overall: [], home: [], away: [] };
        let globalSeasonSchedule = { teams: [], rounds: [], fixtures: {} };
        let globalTeamData = { byId: {}, byFullName: {}, byShortName: {}, byElementType: {}, allPlayers: [] }; // Added allPlayers array
        let userCustomFDRRatings = {};
        let roundsToShow = 5; // Default for both FDR and Teams To Target
        let selectedFDRSystem = 'overall'; // Default FDR system

        // Transfer Planner Specific Global Variables
        const MAX_SQUAD_SIZE = 15;
        const MAX_PLAYERS_PER_TEAM = 3;
        // Positional limits for a valid starting 11 (GKP: 1, DEF: min 3, MID: min 1, FWD: min 1)
        // The sum of these minimums is 1+3+1+1 = 6. The remaining 5 players can be any position.
        // The total number of players on the pitch must be 11.
        const PITCH_MIN_POSITION_COUNTS = { 'GKP': 1, 'DEF': 3, 'MID': 1, 'FWD': 1 }; 
        const INITIAL_PLANNING_ROUND = 2; // Starting point for planning
        const MAX_SAVED_FREE_TRANSFERS = 2; // Configurable: Set to 5 for new season rule
        const POINTS_HIT_PER_TRANSFER = 4;

        let currentPlanningRound = INITIAL_PLANNING_ROUND;
        let currentSquad = []; // Array of player objects with their assigned slot and buying price
        let currentFreeTransfers = 1; // Start with 1 free transfer for Round 2
        let currentPointsHit = 0;
        let currentFunds = 100.0; // Placeholder, will be fetched from manager data
        let pendingTransfers = []; // { type: 'in'/'out', player: playerObject, originalSlotId: ..., originalSlotType: ..., newSlotId: ..., newSlotType: ... }
        let filteredPlayers = []; // For player list on right side
        let activePlayerFilter = 'ALL'; // Current filter for player list

        // --- Helper Functions ---

        const showAuthMessage = (msg, type = 'info') => { if (authMessageBox) { authMessageBox.className = `message-box ${type}`; authMessageBox.textContent = msg; authMessageBox.style.display = 'block'; }};
        const showAdminMessage = (msg, type = 'info') => { if (adminMessage) { adminMessage.className = `message-box ${type}`; adminMessage.textContent = msg; adminMessage.style.display = 'block'; }};
        const showExcelUploadMessage = (msg, type = 'info') => { if (excelUploadMessage) { excelUploadMessage.className = `message-box ${type}`; excelUploadMessage.textContent = msg; excelUploadMessage.style.display = 'block'; }};
        const showApiTeamNamesStatus = (msg, type = 'info') => { if (apiTeamNamesStatus) { apiTeamNamesStatus.className = `message-box ${type}`; apiTeamNamesStatus.textContent = msg; apiTeamNamesStatus.style.display = 'block'; }};
        const showApiScheduleStatus = (msg, type = 'info') => { if (apiScheduleStatus) { apiScheduleStatus.className = `message-box ${type}`; apiScheduleStatus.textContent = msg; apiScheduleStatus.style.display = 'block'; }};
        const showControlRoomMessage = (msg, type = 'info') => { if (controlRoomMessageBox) { controlRoomMessageBox.className = `message-box ${type}`; controlRoomMessageBox.textContent = msg; controlRoomMessageBox.style.display = 'block'; }};
        const showCustomRatingsMessage = (msg, type = 'info') => { if (customRatingsMessageBox) { customRatingsMessageBox.className = `message-box ${type}`; customRatingsMessageBox.textContent = msg; customRatingsMessageBox.style.display = 'block'; }};
        const showSaveFDRSystemMessage = (msg, type = 'info') => { 
            if (saveFDRSystemMessage) { 
                saveFDRSystemMessage.className = `message-box ${type}`; 
                saveFDRSystemMessage.textContent = msg; 
                saveFDRSystemMessage.style.display = 'block'; 
                setTimeout(() => { saveFDRSystemMessage.style.display = 'none'; }, 3000); 
            }
        };
        const showTransferPlannerMessage = (msg, type = 'info') => { 
            if (transferPlannerMessage) { 
                transferPlannerMessage.className = `message-box ${type}`; 
                transferPlannerMessage.textContent = msg; 
                setTimeout(() => { transferPlannerMessage.style.display = 'none'; }, 5000); 
            }
        };

        function hideAllContentSections() {
            [initialLoggedInDashboardContent, analyzerReportContent, myControlRoomContent, adminDashboardContent].forEach(el => el && (el.style.display = 'none'));
            [adminDashboardNavButtons, adminSearchSection, adminSearchResults, adminMessage, dataUploadSection, currentRankingsDisplayAdmin, excelUploadMessage, apiTeamNamesStatus, apiScheduleStatus, overallFDRSectionAdmin, homeFDRSectionAdmin, awayFDRSectionAdmin].forEach(el => el && (el.style.display = 'none'));
            // Also hide FDR, Teams To Target, and Transfer Planner containers when switching main sections
            [fdrSystemsContainer, teamsToTargetContainer, transferPlannerContainer].forEach(el => el && (el.style.display = 'none'));
        }

        function clearAdminSearchAndResults() {
            if (adminSearchInput) adminSearchInput.value = '';
            if (adminUserUidElem) adminUserUidElem.textContent = 'N/A';
            if (adminEditEmailInput) adminEditEmailInput.value = '';
            if (adminEditSplManagerIdInput) adminEditSplManagerIdInput.value = '';
            foundUserForAdminEdit = null;
            if (adminSearchSection) adminSearchSection.style.display = 'none'; 
            if (adminSearchResults) adminSearchResults.style.display = 'none'; 
            if (adminMessage) adminMessage.style.display = 'none';      
        }

        function convertArabicToWesternNumerals(input) {
            const arabicNumerals = ['', '', '', '', '', '', '', '', '', ''];
            const westernNumerals = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
            let convertedInput = input;
            for (let i = 0; i < arabicNumerals.length; i++) {
                const regex = new RegExp(arabicNumerals[i], 'g');
                convertedInput = convertedInput.replace(regex, westernNumerals[i]);
            }
            return convertedInput;
        }

        const setTheme = (theme) => {
            document.body.classList.toggle('dark-mode', theme === 'dark');
            if (mainLogo) mainLogo.src = theme === 'dark' ? darkModeLogoSrc : lightModeLogoSrc;
            if (darkModeToggle) darkModeToggle.checked = theme === 'dark';
            localStorage.setItem('theme', theme);
        };

        // Authentication Logic
        if (signupButton) {
            signupButton.addEventListener('click', async () => {
                showAuthMessage("Processing...", "info"); isProcessingAuth = true;
                const [email, password, confirmPassword, managerId] = [signupEmailInput.value.trim(), signupPasswordInput.value, signupConfirmPasswordInput.value, convertArabicToWesternNumerals(signupManagerIdInput.value.trim())];
                if (!email || !password || !confirmPassword || !managerId) { showAuthMessage("All fields are required.", "error"); isProcessingAuth = false; return; }
                if (password !== confirmPassword) { showAuthMessage("Passwords do not match.", "error"); isProcessingAuth = false; return; }
                if (password.length < 6) { showAuthMessage("Password must be at least 6 characters long.", "error"); isProcessingAuth = false; return; }
                if (!/^\d+$/.test(managerId)) { showAuthMessage("SPL Manager ID is required and must be a valid number.", "error"); isProcessingAuth = false; return; }
                try {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;
                    await setDoc(doc(db, "users", user.uid), { email: user.email, splManagerId: managerId, createdAt: serverTimestamp(), emailVerified: false, preferredFDRSystem: 'overall' });
                    try { await sendEmailVerification(user); } catch (emailError) { console.error("ERROR: Failed to send email verification:", emailError); showAuthMessage(`Account created, but failed to send verification email: ${emailError.message}.`, "warning"); }
                    await signOut(auth); showAuthMessage("Account created! Please verify your email and then log in.", "success");
                    [signupEmailInput, signupPasswordInput, signupConfirmPasswordInput, signupManagerIdInput].forEach(input => input && (input.value = ''));
                    if (loginForm) loginForm.style.display = 'block'; if (signupForm) signupForm.style.display = 'none'; if (instructionsBox) instructionsBox.style.display = 'none';
                } catch (error) { showAuthMessage(`Signup failed: ${error.message}`, "error"); } finally { isProcessingAuth = false; }
            });
        }

        if (loginButton) {
            loginButton.addEventListener('click', async () => {
                showAuthMessage("Logging in...", "info"); isProcessingAuth = true;
                const [email, password] = [loginEmailInput.value.trim(), loginPasswordInput.value];
                try {
                    const userCredential = await signInWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;
                    await reload(user); 
                    if (!user.emailVerified) { await signOut(auth); showAuthMessage("Please verify your email address before logging in.", "info"); return; }
                    const userDocRef = doc(db, "users", user.uid);
                    const userDocSnap = await getDoc(userDocRef);
                    if (userDocSnap.exists()) {
                        const userData = userDocSnap.data();
                        if (!userData.emailVerified && user.emailVerified) { await updateDoc(userDocRef, { emailVerified: true }); }
                        currentManagerId = userData.splManagerId;
                        if (currentManagerId && /^\d+$/.test(currentManagerId)) {
                            if (displayLoggedInManagerId) displayLoggedInManagerId.textContent = currentManagerId;
                            if (authSection) authSection.style.display = 'none'; if (loggedInContent) loggedInContent.style.display = 'block';
                            isAdminUser = (await getDoc(doc(db, "admins", user.uid))).exists();
                            if (menuAdminDashboard) menuAdminDashboard.style.display = isAdminUser ? 'block' : 'none';
                            if (menuToggle) menuToggle.style.display = 'block';
                            showContentSection('initialLoggedInDashboard');
                            await fetchGlobalFDRData(); // Fetch global data on login
                        } else { showAuthMessage("No valid SPL Manager ID found. Contact support.", "error"); await signOut(auth); }
                    } else { showAuthMessage("User data not found. Contact support.", "error"); await signOut(auth); }
                    if (loginPasswordInput) loginPasswordInput.value = '';
                } catch (error) { showAuthMessage(`Login failed: ${error.message}`, "error"); } finally { isProcessingAuth = false; }
            });
        }

        if (logoutButton) {
            logoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth); showAuthMessage("Logged out successfully.", "info"); 
                    isAdminUser = false; if (menuAdminDashboard) menuAdminDashboard.style.display = 'none';
                    if (menuToggle) menuToggle.style.display = 'none'; if (loggedInContent) loggedInContent.style.display = 'none'; 
                    if (authSection) authSection.style.display = 'block'; if (loginForm) loginForm.style.display = 'block'; 
                    if (signupForm) signupForm.style.display = 'none'; if (instructionsBox) instructionsBox.style.display = 'none';
                    if (sidebarMenu) sidebarMenu.classList.remove('open'); if (overlay) overlay.style.display = 'none';
                    if (sidebarTeamName) sidebarTeamName.textContent = 'Your Team'; if (displayLoggedInManagerId) displayLoggedInManagerId.textContent = '';
                } catch (error) { showAuthMessage(`Logout error: ${error.message}`, "error"); }
            });
        }

        if (showSignupLink) { showSignupLink.addEventListener('click', (e) => { e.preventDefault(); if (loginForm) loginForm.style.display = 'none'; if (signupForm) signupForm.style.display = 'block'; if (authMessageBox) authMessageBox.style.display = 'none'; if (authMessageBox) authMessageBox.textContent = ''; if (instructionsBox) instructionsBox.style.display = 'block'; }); }
        if (showLoginLink) { showLoginLink.addEventListener('click', (e) => { e.preventDefault(); if (loginForm) loginForm.style.display = 'block'; if (signupForm) signupForm.style.display = 'none'; if (authMessageBox) authMessageBox.style.display = 'none'; if (authMessageBox) authMessageBox.textContent = ''; if (instructionsBox) instructionsBox.style.display = 'none'; }); }

        // Auth State Listener
        onAuthStateChanged(auth, async (user) => {
            if (isProcessingAuth) return;
            if (user) {
                await reload(user); 
                if (user.emailVerified) {
                    const userDocRef = doc(db, "users", user.uid);
                    const userDocSnap = await getDoc(userDocRef);
                    if (userDocSnap.exists()) {
                        const userData = userDocSnap.data();
                        if (!userData.emailVerified && user.emailVerified) { await updateDoc(userDocRef, { emailVerified: true }); }
                        currentManagerId = userData.splManagerId;
                        if (currentManagerId && /^\d+$/.test(currentManagerId)) {
                            if (displayLoggedInManagerId) displayLoggedInManagerId.textContent = currentManagerId;
                            if (authSection) authSection.style.display = 'none'; if (loggedInContent) loggedInContent.style.display = 'block';
                            isAdminUser = (await getDoc(doc(db, "admins", user.uid))).exists();
                            if (menuAdminDashboard) menuAdminDashboard.style.display = isAdminUser ? 'block' : 'none';
                            if (menuToggle) menuToggle.style.display = 'block';
                            showContentSection('initialLoggedInDashboard');
                            await fetchGlobalFDRData(); // Fetch global data on auth state change
                        } else { showAuthMessage("No valid SPL Manager ID found. Logging out.", "error"); await signOut(auth); }
                    } else { showAuthMessage("User data not found. Logging out.", "error"); await signOut(auth); }
                } else { showAuthMessage("Please verify your email address.", "info"); if (authSection) authSection.style.display = 'block'; if (loginForm) loginForm.style.display = 'block'; if (signupForm) signupForm.style.display = 'none'; if (loggedInContent) loggedInContent.style.display = 'none'; }
            } else {
                if (authSection) authSection.style.display = 'block'; if (loginForm) loginForm.style.display = 'block'; if (signupForm) signupForm.style.display = 'none'; if (loggedInContent) loggedInContent.style.display = 'none';
                isAdminUser = false; if (menuAdminDashboard) menuAdminDashboard.style.display = 'none'; if (menuToggle) menuToggle.style.display = 'none';
                if (instructionsBox) instructionsBox.style.display = 'none'; if (sidebarMenu) sidebarMenu.classList.remove('open'); if (overlay) overlay.style.display = 'none';
                if (sidebarTeamName) sidebarTeamName.textContent = 'Your Team'; if (displayLoggedInManagerId) displayLoggedInManagerId.textContent = '';
            }
        });

        // Content Section Management
        async function showContentSection(sectionId) {
            hideAllContentSections();
            if (sectionId === 'initialLoggedInDashboard') { if (initialLoggedInDashboardContent) initialLoggedInDashboardContent.style.display = 'flex'; }
            else if (sectionId === 'analyzerReport') { if (analyzerReportContent) analyzerReportContent.style.display = 'block'; }
            else if (sectionId === 'controlRoom') { 
                if (myControlRoomContent) myControlRoomContent.style.display = 'block'; 
                // Initially hide all FDR-related containers within Control Room
                if (fdrSystemsContainer) fdrSystemsContainer.style.display = 'none';
                if (teamsToTargetContainer) teamsToTargetContainer.style.display = 'none'; 
                if (transferPlannerContainer) transferPlannerContainer.style.display = 'none'; 
                // No default display for FDR/TeamsToTarget/TransferPlanner on initial Control Room load
            }
            else if (sectionId === 'adminDashboard') {
                if (isAdminUser) { 
                    if (adminDashboardContent) adminDashboardContent.style.display = 'flex'; 
                    if (adminDashboardNavButtons) adminDashboardNavButtons.style.display = 'flex'; 
                    if (adminUsersButton) adminUsersButton.click(); 
                    showAdminMessage("Admin Dashboard loaded. Select an option.", "info"); 
                } else { /* showGeneralErrorMessage("Access Denied: You do not have administrator privileges.", "error"); */ } 
            }
        }

        // Admin Dashboard Logic
        const searchUserByUid = async (uid) => { try { const docSnap = await getDoc(doc(db, "users", uid)); return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } : null; } catch (e) { console.error("Error searching by UID:", e); return null; } };
        const searchUserByEmail = async (email) => { if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return null; try { const q = query(collection(db, "users"), where("email", "==", email)); const querySnapshot = await getDocs(q); return !querySnapshot.empty ? { id: querySnapshot.docs[0].id, ...querySnapshot.docs[0].data() } : null; } catch (e) { console.error("Error searching by Email:", e); return null; } };
        const searchUserBySplManagerId = async (splId) => { const convertedId = convertArabicToWesternNumerals(splId); if (!/^\d+$/.test(convertedId)) return null; try { const q = query(collection(db, "users"), where("splManagerId", "==", convertedId)); const querySnapshot = await getDocs(q); return !querySnapshot.empty ? { id: querySnapshot.docs[0].id, ...querySnapshot.docs[0].data() } : null; } catch (e) { console.error("Error searching by SPL ID:", e); return null; } };

        if (adminSearchButton) {
            adminSearchButton.addEventListener('click', async () => {
                showAdminMessage("Searching...", "info"); if (adminSearchResults) adminSearchResults.style.display = 'none'; foundUserForAdminEdit = null;
                const searchTerm = adminSearchInput.value.trim();
                if (!searchTerm) { showAdminMessage("Please enter a search term.", "error"); return; }
                let userFoundData = await searchUserByUid(searchTerm) || (searchTerm.includes('@') && await searchUserByEmail(searchTerm)) || (/^\d+$/.test(searchTerm) && await searchUserBySplManagerId(searchTerm));
                if (userFoundData) {
                    foundUserForAdminEdit = userFoundData; if (adminUserUidElem) adminUserUidElem.textContent = userFoundData.id;
                    if (adminEditEmailInput) adminEditEmailInput.value = userFoundData.email || ''; if (adminEditSplManagerIdInput) adminEditSplManagerIdInput.value = userFoundData.splManagerId || '';
                    if (adminSearchResults) adminSearchResults.style.display = 'flex'; showAdminMessage("User found.", "success");
                } else { showAdminMessage("User not found.", "error"); if (adminSearchResults) adminSearchResults.style.display = 'none'; }
            });
        }
        if (adminSearchInput) { adminSearchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); if (adminSearchButton) adminSearchButton.click(); } }); }

        if (adminUpdateUserButton) {
            adminUpdateUserButton.addEventListener('click', async () => {
                if (!foundUserForAdminEdit) { showAdminMessage("No user selected.", "error"); return; }
                showAdminMessage("Updating user...", "info");
                const [newEmail, newSplManagerId, userToUpdateUid] = [adminEditEmailInput.value.trim(), convertArabicToWesternNumerals(adminEditSplManagerIdInput.value.trim()), foundUserForAdminEdit.id];
                if (!newEmail || !newSplManagerId || !/^\d+$/.test(newSplManagerId)) { showAdminMessage("Invalid input.", "error"); return; }
                try { await updateDoc(doc(db, "users", userToUpdateUid), { email: newEmail, splManagerId: newSplManagerId }); showAdminMessage("User updated!", "success"); if (adminSearchInput) adminSearchInput.value = userToUpdateUid; if (adminSearchButton) await adminSearchButton.click(); }
                catch (error) { showAdminMessage(`Update failed: ${error.message}`, "error"); }
            });
        }

        if (adminUsersButton) { adminUsersButton.addEventListener('click', () => { if (adminSearchSection) adminSearchSection.style.display = 'flex'; if (adminSearchResults) adminSearchResults.style.display = 'none'; if (adminMessage) adminMessage.style.display = 'none'; if (dataUploadSection) dataUploadSection.style.display = 'none'; if (currentRankingsDisplayAdmin) currentRankingsDisplayAdmin.style.display = 'none'; if (overallFDRSectionAdmin) overallFDRSectionAdmin.style.display = 'none'; if (homeFDRSectionAdmin) homeFDRSectionAdmin.style.display = 'none'; if (awayFDRSectionAdmin) awayFDRSectionAdmin.style.display = 'none'; if (apiTeamNamesStatus) apiTeamNamesStatus.style.display = 'none'; if (apiScheduleStatus) apiScheduleStatus.style.display = 'none'; showAdminMessage("Enter user details to search.", "info"); }); }
        if (adminDataButton) {
            adminDataButton.addEventListener('click', async () => {
                if (adminSearchSection) adminSearchSection.style.display = 'none'; if (adminSearchResults) adminSearchResults.style.display = 'none'; if (adminMessage) adminMessage.style.display = 'none';
                if (dataUploadSection) dataUploadSection.style.display = 'block'; if (currentRankingsDisplayAdmin) currentRankingsDisplayAdmin.style.display = 'block';
                showExcelUploadMessage("Upload your league table Excel file here.", "info");
                if (apiTeamNamesStatus) apiTeamNamesStatus.style.display = 'block'; if (apiScheduleStatus) apiScheduleStatus.style.display = 'block';
                await fetchGlobalFDRData();
                renderFDRScale(overallFDRScaleAdmin, 7); renderFDRScale(homeFDRScaleAdmin, 6); renderFDRScale(awayFDRScaleAdmin, 6);
                fetchAndRenderRankings(excelUploadMessage, overallFDRGridAdmin, homeFDRGridAdmin, awayFDRGridAdmin, overallFDRSectionAdmin, homeFDRSectionAdmin, awayFDRSectionAdmin, currentRankingsDisplayAdmin, null);
            });
        }

        // Excel Upload Logic
        if (excelFileUploadInput) {
            excelFileUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0]; if (!file) { showExcelUploadMessage('No file selected.', "error"); return; }
                if (typeof window.XLSX === 'undefined') { showExcelUploadMessage('Excel library not loaded.', "error"); return; }
                showExcelUploadMessage('Processing Excel file...', "info");
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const workbook = XLSX.read(new Uint8Array(event.target.result), { type: 'array' });
                        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonRows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        if (jsonRows.length < 2) { showExcelUploadMessage('Excel file empty.', "error"); return; }
                        const headerRow = jsonRows[0].map(h => String(h).trim().toLowerCase());
                        const selectedRankingType = rankingTypeSelect.value;
                        let expectedHeaders, fdrColName1, fdrColName2, fdrColNameSingle, maxFDRScale;

                        if (selectedRankingType === 'overall') { expectedHeaders = { rank: ['rank'], team: ['team'], fdrHome: ['fdr home'], fdrAway: ['fdr away'] }; fdrColName1 = 'fdrHome'; fdrColName2 = 'fdrAway'; maxFDRScale = 7; }
                        else if (selectedRankingType === 'home') { expectedHeaders = { rank: ['rank'], team: ['team'], fdrAway: ['fdr away'] }; fdrColNameSingle = 'fdrAway'; maxFDRScale = 6; }
                        else if (selectedRankingType === 'away') { expectedHeaders = { rank: ['rank'], team: ['team'], fdrHome: ['fdr home'] }; fdrColNameSingle = 'fdrHome'; maxFDRScale = 6; }
                        else { showExcelUploadMessage('Invalid ranking type.', "error"); return; }

                        const getColIdx = (headers, aliases) => aliases.map(a => headers.indexOf(a)).find(idx => idx !== -1) || -1;
                        const [rankIdx, teamIdx] = [getColIdx(headerRow, expectedHeaders.rank), getColIdx(headerRow, expectedHeaders.team)];
                        let [fdrCol1Idx, fdrCol2Idx, fdrColSingleIdx] = [-1, -1, -1];

                        if (selectedRankingType === 'overall') { fdrCol1Idx = getColIdx(headerRow, expectedHeaders.fdrHome); fdrCol2Idx = getColIdx(headerRow, expectedHeaders.fdrAway); if ([rankIdx, teamIdx, fdrCol1Idx, fdrCol2Idx].includes(-1)) { showExcelUploadMessage('Missing Overall headers.', "error"); return; } }
                        else { fdrColSingleIdx = getColIdx(headerRow, expectedHeaders[fdrColNameSingle]); if ([rankIdx, teamIdx, fdrColSingleIdx].includes(-1)) { showExcelUploadMessage(`Missing ${selectedRankingType} headers.`, "error"); return; } }

                        const parsedRankings = [];
                        for (let i = 1; i < jsonRows.length; i++) {
                            const row = jsonRows[i]; const rawTeamName = String(row[teamIdx]).trim(); const rank = parseInt(row[rankIdx], 10);
                            let matchedApiTeamName = globalTeamData.byFullName[rawTeamName] ? rawTeamName : (Object.keys(globalTeamData.byFullName).find(apiName => (apiName.startsWith('Al ') ? apiName.substring(3) : apiName).toLowerCase() === rawTeamName.toLowerCase()) || (globalTeamData.byFullName[`Al ${rawTeamName}`] ? `Al ${rawTeamName}` : null));
                            if (!matchedApiTeamName) { console.warn(`Skipping row ${i+1} for team "${rawTeamName}" due to no API match.`); continue; }
                            const team = matchedApiTeamName; let isValid = false;

                            if (selectedRankingType === 'overall') {
                                const [fdrVal1, fdrVal2] = [parseInt(row[fdrCol1Idx], 10), parseInt(row[fdrCol2Idx], 10)];
                                if (!isNaN(rank) && team && !isNaN(fdrVal1) && !isNaN(fdrVal2) && fdrVal1 >=1 && fdrVal1 <= maxFDRScale && fdrVal2 >= 1 && fdrVal2 <= maxFDRScale) { parsedRankings.push({ rank, team, fdrHome: fdrVal1, fdrAway: fdrVal2 }); isValid = true; }
                            } else {
                                const fdrVal1 = parseInt(row[fdrColSingleIdx], 10);
                                if (!isNaN(rank) && team && !isNaN(fdrVal1) && fdrVal1 >=1 && fdrVal1 <= maxFDRScale) {
                                    parsedRankings.push(selectedRankingType === 'home' ? { rank, team, fdrAway: fdrVal1 } : { rank, team, fdrHome: fdrVal1 }); isValid = true;
                                }
                            }
                            if (!isValid) { console.warn(`Skipping row ${i+1} due to invalid data or FDR out of range.`); }
                        }
                        if (parsedRankings.length === 0) { showExcelUploadMessage(`No valid ranking data found.`, "error"); return; }
                        await setDoc(doc(db, 'splRankings', "2025-2026"), { season: "2025-2026", lastUpdated: serverTimestamp(), [selectedRankingType]: parsedRankings }, { merge: true });
                        showExcelUploadMessage(`Successfully uploaded ${selectedRankingType} rankings!`, "success"); e.target.value = null;
                        await fetchGlobalFDRData();
                        fetchAndRenderRankings(excelUploadMessage, overallFDRGridAdmin, homeFDRGridAdmin, awayFDRGridAdmin, overallFDRSectionAdmin, homeFDRSectionAdmin, awayFDRSectionAdmin, currentRankingsDisplayAdmin, null);
                    } catch (error) { showExcelUploadMessage(`Failed to process Excel: ${error.message}.`, "error"); }
                };
                reader.readAsArrayBuffer(file);
            });
        }
        // Fetch Global Data (FDR, Teams, Players, Schedule)
        async function fetchGlobalFDRData() {
            const seasonId = "2025-2026"; const splRankingsDocRef = doc(db, 'splRankings', seasonId);
            try {
                showApiTeamNamesStatus("Fetching team names and player data from API...", "info");
                const bootstrapProxyResponse = await fetch(`/api/spl-proxy?url=${encodeURIComponent(API_BOOTSTRAP_STATIC)}`);
                if (!bootstrapProxyResponse.ok) throw new Error(`HTTP error! status: ${bootstrapProxyResponse.status} from proxy for bootstrap-static`);
                const bootstrapData = await bootstrapProxyResponse.json();
                
                globalTeamData = { byId: {}, byFullName: {}, byShortName: {}, byElementType: {}, allPlayers: [] };
                if (bootstrapData && bootstrapData.teams && bootstrapData.elements && bootstrapData.element_types) {
                    bootstrapData.teams.forEach(team => { globalTeamData.byId[team.id] = { id: team.id, name: team.name, short_name: team.short_name }; globalTeamData.byFullName[team.name] = { id: team.id, name: team.name, short_name: team.short_name }; globalTeamData.byShortName[team.short_name] = { id: team.id, name: team.name, short_name: team.short_name }; });
                    bootstrapData.element_types.forEach(type => { globalTeamData.byElementType[type.id] = type.singular_name_short; }); // Store position names
                    
                    // Store all players with their full data
                    globalTeamData.allPlayers = bootstrapData.elements.map(player => ({
                        id: player.id,
                        name: player.web_name,
                        first_name: player.first_name,
                        second_name: player.second_name,
                        team_id: player.team,
                        team_name: globalTeamData.byId[player.team]?.name,
                        team_short_name: globalTeamData.byId[player.team]?.short_name,
                        position_id: player.element_type,
                        position_short: globalTeamData.byElementType[player.element_type],
                        current_price: player.now_cost / 10, // Convert to actual price (e.g., 5.5)
                        total_points: player.total_points,
                        status: player.status, // 'a', 'i', 's', 'd' etc.
                        chance_of_playing_this_round: player.chance_of_playing_this_round,
                        chance_of_playing_next_round: player.chance_of_playing_next_round,
                        // Add other relevant fields if needed for future features
                    }));

                    showApiTeamNamesStatus(`Team Names and Player Data fetched successfully. Found ${Object.keys(globalTeamData.byId).length} teams and ${globalTeamData.allPlayers.length} players.`, "success");
                } else { showApiTeamNamesStatus("Team Names and Player Data could not be fetched.", "error"); }

                showApiScheduleStatus("Fetching season schedule from API...", "info");
                globalSeasonSchedule = { teams: [], rounds: [], fixtures: {} };
                const maxRound = 34; const fixtureFetchPromises = [];
                for (let round = 1; round <= maxRound; round++) { fixtureFetchPromises.push(fetch(`/api/spl-proxy?url=${encodeURIComponent(`${API_FIXTURES_BASE}${round}`)}`).then(res => { if (!res.ok) throw new Error(`HTTP error! status: ${res.status} for round ${round}`); return res.json(); }).then(data => ({ round, data })).catch(error => ({ round, data: null, error: error }))); }
                const allFixturesData = await Promise.all(fixtureFetchPromises);

                const processedFixtures = {}; const allTeamNamesInSchedule = new Set(); const allRoundNamesInSchedule = new Set();
                allFixturesData.forEach(({ round, data }) => {
                    if (data && data.length > 0) {
                        const roundName = `R${round}`; allRoundNamesInSchedule.add(roundName);
                        data.forEach(fixture => {
                            if (fixture.event === round) {
                                const [homeTeam, awayTeam] = [globalTeamData.byId[fixture.team_h], globalTeamData.byId[fixture.team_a]];
                                if (homeTeam && awayTeam) {
                                    allTeamNamesInSchedule.add(homeTeam.name); allTeamNamesInSchedule.add(awayTeam.name);
                                    if (!processedFixtures[homeTeam.name]) processedFixtures[homeTeam.name] = {};
                                    if (!processedFixtures[homeTeam.name][roundName]) processedFixtures[homeTeam.name][roundName] = [];
                                    processedFixtures[homeTeam.name][roundName].push(`${awayTeam.short_name} `);
                                    if (!processedFixtures[awayTeam.name]) processedFixtures[awayTeam.name] = {};
                                    if (!processedFixtures[awayTeam.name][roundName]) processedFixtures[awayTeam.name][roundName] = [];
                                    processedFixtures[awayTeam.name][roundName].push(`${homeTeam.short_name} `);
                                }
                            }
                        });
                    } else {
                        const allKnownTeams = Object.values(globalTeamData.byFullName).map(team => team.name);
                        const roundName = `R${round}`; allRoundNamesInSchedule.add(roundName);
                        allKnownTeams.forEach(teamFullName => { 
                            if (!processedFixtures[teamFullName]) processedFixtures[teamFullName] = {}; 
                            if (!processedFixtures[teamFullName][roundName]) { processedFixtures[teamFullName][roundName] = []; } 
                        });
                    }
                });
                globalSeasonSchedule.fixtures = processedFixtures;
                globalSeasonSchedule.teams = Array.from(allTeamNamesInSchedule).sort();
                globalSeasonSchedule.rounds = Array.from(allRoundNamesInSchedule).sort((a, b) => parseInt(a.substring(1)) - parseInt(b.substring(1)));
                if (Object.keys(globalSeasonSchedule.fixtures).length > 0) { showApiScheduleStatus(`Schedule fetched. ${globalSeasonSchedule.rounds.length} rounds, ${globalSeasonSchedule.teams.length} teams.`, "success"); }
                else { showApiScheduleStatus("Schedule could not be fetched.", "error"); }

                const rankingsSnap = await getDoc(splRankingsDocRef);
                if (rankingsSnap.exists() && rankingsSnap.data()) {
                    const data = rankingsSnap.data();
                    globalSplRankings.overall = data.overall || []; globalSplRankings.home = data.home || []; globalSplRankings.away = data.away || [];
                } else { globalSplRankings = { overall: [], home: [], away: [] }; }
            } catch (error) {
                console.error("Error fetching global FDR data:", error);
                showApiTeamNamesStatus(`Error fetching Team Names/Players: ${error.message}`, "error");
                showApiScheduleStatus(`Error fetching Schedule: ${error.message}`, "error");
            }
        }

        // Get FDR Value
        function getFDRValue(teamFullName, opponentShortCode, isHomeGame, fdrType, customRatings = {}) {
            const opponentTeamData = globalTeamData.byShortName[opponentShortCode];
            const opponentFullName = opponentTeamData?.name;
            if (!opponentFullName) return null;

            if (fdrType === 'customized') {
                const ratingKey = isHomeGame ? `${opponentFullName}_Away` : `${opponentFullName}_Home`;
                const fdrValue = customRatings[ratingKey];
                return (typeof fdrValue === 'number' && fdrValue >= 1 && fdrValue <= 7) ? fdrValue : null;
            }

            if (!globalSplRankings || (!globalSplRankings.overall.length && !globalSplRankings.home.length && !globalSplRankings.away.length)) return null;

            let fdrValue = null;
            if (fdrType === 'overall') {
                const opponentOverallData = globalSplRankings.overall.find(item => item.team === opponentFullName);
                if (opponentOverallData) fdrValue = isHomeGame ? opponentOverallData.fdrAway : opponentOverallData.fdrHome;
            } else if (fdrType === 'homeAway') {
                if (isHomeGame) { const opponentHomeData = globalSplRankings.home.find(item => item.team === opponentFullName); if (opponentHomeData) fdrValue = opponentHomeData.fdrAway; }
                else { const opponentAwayData = globalSplRankings.away.find(item => item.team === opponentFullName); if (opponentAwayData) fdrValue = opponentAwayData.fdrHome; }
            }
            const maxScale = (fdrType === 'homeAway') ? 6 : 7;
            return (typeof fdrValue === 'number' && fdrValue >= 1 && fdrValue <= maxScale) ? fdrValue : null;
        }

        // Render Schedule Grid (for FDR display)
        function renderScheduleGrid(gridContainerElement, scheduleData, fdrType, customRatings = {}) {
            gridContainerElement.innerHTML = '';
            if (!scheduleData || !scheduleData.fixtures || Object.keys(scheduleData.fixtures).length === 0 || !scheduleData.teams || scheduleData.teams.length === 0 || !scheduleData.rounds || scheduleData.rounds.length === 0) {
                gridContainerElement.innerHTML = '<div style="grid-column: 1 / -1; text-align:center; padding: 20px; color: var(--spl-text-medium);">No season schedule data available. Please ensure schedule data is fetched from API.</div>'; return;
            }
            
            const teamsToDisplay = scheduleData.teams;
            const allRounds = scheduleData.rounds;
            const roundsToRender = allRounds.slice(0, roundsToShow); // Use global roundsToShow
            gridContainerElement.style.gridTemplateColumns = `minmax(100px, 1fr) repeat(${roundsToRender.length}, minmax(70px, 1fr))`;

            const teamHeader = document.createElement('div'); teamHeader.className = 'grid-header-cell'; teamHeader.textContent = 'Team'; gridContainerElement.appendChild(teamHeader);
            roundsToRender.forEach(round => { const roundHeader = document.createElement('div'); roundHeader.className = 'grid-header-cell'; roundHeader.textContent = round; gridContainerElement.appendChild(roundHeader); });

            teamsToDisplay.forEach(teamFullName => {
                const teamCell = document.createElement('div'); teamCell.className = 'grid-row-team-cell'; teamCell.textContent = teamFullName; gridContainerElement.appendChild(teamCell);
                const teamFixtures = scheduleData.fixtures[teamFullName] || {};
                roundsToRender.forEach(round => {
                    const fixtureCell = document.createElement('div'); fixtureCell.className = 'grid-fixture-cell';
                    const fixturesForThisRound = teamFixtures[round] || [];
                    if (fixturesForThisRound.length > 0) {
                        fixturesForThisRound.forEach(fixtureString => {
                            const fixtureDisplayItem = document.createElement('div'); fixtureDisplayItem.className = `fixture-item-display`;
                            const match = fixtureString.match(/(.+?)\s*(|)?$/);
                            const [opponentShortCode, homeAwayEmoji, isHomeGame] = [match[1].trim(), match[2] || '', (match[2] === '')];
                            fixtureDisplayItem.textContent = `${opponentShortCode} ${homeAwayEmoji}`;
                            fixtureCell.appendChild(fixtureDisplayItem);
                            const fdrValue = getFDRValue(teamFullName, opponentShortCode, isHomeGame, fdrType, customRatings);
                            fixtureCell.classList.add(fdrValue !== null ? `fdr-${fdrValue}` : 'fdr-na');
                        });
                    } else { fixtureCell.textContent = ''; fixtureCell.classList.add('fdr-na'); }
                    gridContainerElement.appendChild(fixtureCell);
                });
            });
        }

        // Render Custom Ratings Input Grid
        function renderCustomRatingsInputGrid(gridElement, teams, currentCustomRatings) {
            gridElement.innerHTML = ''; gridElement.style.gridTemplateColumns = `1fr 80px 80px`;
            ['Team', 'Home', 'Away'].forEach(headerText => { const headerDiv = document.createElement('div'); headerDiv.className = 'custom-ratings-grid-header'; headerDiv.textContent = headerText; gridElement.appendChild(headerDiv); });

            teams.forEach(teamFullName => {
                const teamCell = document.createElement('div'); teamCell.className = 'custom-ratings-grid-item'; teamCell.textContent = teamFullName; gridElement.appendChild(teamCell);

                const createSelect = (homeAwayType) => {
                    const select = document.createElement('select');
                    select.dataset.teamFullName = teamFullName;
                    select.dataset.homeAway = homeAwayType;
                    const emptyOption = document.createElement('option'); emptyOption.value = ''; emptyOption.textContent = '-'; select.appendChild(emptyOption);
                    for (let i = 1; i <= 7; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i; select.appendChild(option); }
                    select.value = currentCustomRatings[`${teamFullName}_${homeAwayType}`] || '';
                    return select;
                };

                const homeSelectCell = document.createElement('div'); homeSelectCell.className = 'custom-ratings-grid-item'; homeSelectCell.appendChild(createSelect('Home')); gridElement.appendChild(homeSelectCell);
                const awaySelectCell = document.createElement('div'); awaySelectCell.className = 'custom-ratings-grid-item'; awaySelectCell.appendChild(createSelect('Away')); gridElement.appendChild(awaySelectCell);
            });
        }

        // Render FDR Scale
        function renderFDRScale(scaleElement, maxScale) {
            scaleElement.innerHTML = '';
            const labels = { 1: 'Very Easy', 7: 'Very Hard' };
            if (maxScale === 6) { labels[6] = 'Very Hard'; delete labels[7]; }
            for (let i = 1; i <= maxScale; i++) {
                const div = document.createElement('div'); div.className = `fdr-level fdr-${i}`; div.textContent = i;
                if (labels[i]) { const span = document.createElement('span'); span.textContent = labels[i]; div.appendChild(span); }
                scaleElement.appendChild(div);
            }
        }

        // Fetch and Render Rankings (Admin & Control Room)
        async function fetchAndRenderRankings(messageBox, overallGridOrList, homeGridOrList, awayGridOrList, overallSection, homeSection, awaySection, displayContainer, selectedFdrSystemParam = null) {
            messageBox.className = 'message-box info'; messageBox.textContent = 'Loading FDR data...'; messageBox.style.display = 'block';
            [overallGridOrList, homeGridOrList, awayGridOrList].forEach(el => el && (el.innerHTML = ''));
            [overallSection, homeSection, awaySection].forEach(el => el && (el.style.display = 'none'));
            
            let hasDataToDisplay = false;

            if (!selectedFdrSystemParam) { // Admin Dashboard
                if (globalSplRankings.overall.length > 0) {
                    globalSplRankings.overall.sort((a, b) => ((b.fdrHome + b.fdrAway) / 2) - ((a.fdrHome + a.fdrAway) / 2));
                    globalSplRankings.overall.forEach(item => {
                        const awayItem = document.createElement('div'); awayItem.className = `fdr-grid-item fdr-${item.fdrAway}`; awayItem.innerHTML = `${item.team} `; overallGridOrList.appendChild(awayItem);
                        const homeItem = document.createElement('div'); homeItem.className = `fdr-grid-item fdr-${item.fdrHome}`; homeItem.innerHTML = `${item.team} `; overallGridOrList.appendChild(homeItem);
                    });
                    if (overallSection) overallSection.style.display = 'block'; hasDataToDisplay = true;
                } else { if (overallGridOrList) overallGridOrList.innerHTML = '<div style="grid-column: 1 / -1; text-align:center; padding: 20px; color: var(--spl-text-medium);">No Overall rankings data available.</div>'; }

                if (globalSplRankings.home.length > 0) {
                    globalSplRankings.home.sort((a, b) => b.fdrAway - a.fdrAway);
                    globalSplRankings.home.forEach(item => { const teamItem = document.createElement('div'); teamItem.className = `fdr-grid-item fdr-${item.fdrAway}`; teamItem.innerHTML = `${item.team} `; homeGridOrList.appendChild(teamItem); });
                    if (homeSection) homeSection.style.display = 'block'; hasDataToDisplay = true;
                } else { if (homeGridOrList) homeGridOrList.innerHTML = '<div style="grid-column: 1 / -1; text-align:center; padding: 20px; color: var(--spl-text-medium);">No Home rankings data available.</div>'; }

                if (globalSplRankings.away.length > 0) {
                    globalSplRankings.away.sort((a, b) => b.fdrHome - a.fdrHome);
                    globalSplRankings.away.forEach(item => { const teamItem = document.createElement('div'); teamItem.className = `fdr-grid-item fdr-${item.fdrHome}`; teamItem.innerHTML = `${item.team} `; awayGridOrList.appendChild(teamItem); });
                    if (awaySection) awaySection.style.display = 'block'; hasDataToDisplay = true;
                } else { if (awayGridOrList) awayGridOrList.innerHTML = '<div style="grid-column: 1 / -1; text-align:center; padding: 20px; color: var(--spl-text-medium);">No Away rankings data available.</div>'; }
            } 

            if (hasDataToDisplay) { messageBox.className = 'message-box success'; messageBox.textContent = 'FDR data loaded.'; }
            else { messageBox.className = 'message-box info'; messageBox.textContent = 'No relevant FDR data found for display. Please ensure league data is uploaded via Admin Dashboard, and API data is fetched.'; }
        }

        // Render Teams To Target Schedule Grid
        function renderTeamsToTargetScheduleGrid(scheduleData, fdrType, customRatings) {
            teamsToTargetScheduleGrid.innerHTML = '';
            if (!scheduleData || !scheduleData.fixtures || Object.keys(scheduleData.fixtures).length === 0 || !scheduleData.teams || scheduleData.teams.length === 0 || !scheduleData.rounds || scheduleData.rounds.length === 0) {
                teamsToTargetScheduleGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align:center; padding: 20px; color: var(--spl-text-medium);">No season schedule data available. Please ensure schedule data is fetched from API.</div>'; return;
            }

            const teamsWithFDRTotal = [];
            const allRounds = scheduleData.rounds;
            const roundsToCalculate = allRounds.slice(0, roundsToShow); // Use global roundsToShow for Teams To Target

            scheduleData.teams.forEach(teamFullName => {
                let fdrTotal = 0;
                let hasValidFixtures = false;
                const teamFixtures = scheduleData.fixtures[teamFullName] || {};

                roundsToCalculate.forEach(round => {
                    const fixturesForThisRound = teamFixtures[round] || [];
                    if (fixturesForThisRound.length > 0) {
                        fixturesForThisRound.forEach(fixtureString => {
                            const match = fixtureString.match(/(.+?)\s*(|)?$/);
                            const [opponentShortCode, homeAwayEmoji, isHomeGame] = [match[1].trim(), match[2] || '', (match[2] === '')];
                            const fdrValue = getFDRValue(teamFullName, opponentShortCode, isHomeGame, fdrType, customRatings);
                            if (fdrValue !== null) {
                                fdrTotal += fdrValue;
                                hasValidFixtures = true;
                            }
                        });
                    }
                });
                // Only add team if it has at least one valid fixture in the selected rounds
                if (hasValidFixtures) {
                    teamsWithFDRTotal.push({ teamFullName, fdrTotal });
                }
            });

            // Sort teams by FDR Total (lowest first)
            teamsWithFDRTotal.sort((a, b) => a.fdrTotal - b.fdrTotal);

            // Determine grid columns: Team, Rounds, FDR Total
            teamsToTargetScheduleGrid.style.gridTemplateColumns = `minmax(100px, 1fr) repeat(${roundsToCalculate.length}, minmax(70px, 1fr)) minmax(80px, 0.5fr)`;

            // Add headers
            const teamHeader = document.createElement('div'); teamHeader.className = 'grid-header-cell'; teamHeader.textContent = 'Team'; teamsToTargetScheduleGrid.appendChild(teamHeader);
            roundsToCalculate.forEach(round => { const roundHeader = document.createElement('div'); roundHeader.className = 'grid-header-cell'; roundHeader.textContent = round; teamsToTargetScheduleGrid.appendChild(roundHeader); });
            const fdrTotalHeader = document.createElement('div'); fdrTotalHeader.className = 'grid-header-cell fdr-total-header'; fdrTotalHeader.textContent = 'FDR Total'; teamsToTargetScheduleGrid.appendChild(fdrTotalHeader);

            // Add team rows
            teamsWithFDRTotal.forEach(teamData => {
                const teamFullName = teamData.teamFullName;
                const teamCell = document.createElement('div'); teamCell.className = 'grid-row-team-cell'; teamCell.textContent = teamFullName; teamsToTargetScheduleGrid.appendChild(teamCell);
                const teamFixtures = scheduleData.fixtures[teamFullName] || {};

                roundsToCalculate.forEach(round => {
                    const fixtureCell = document.createElement('div'); fixtureCell.className = 'grid-fixture-cell';
                    const fixturesForThisRound = teamFixtures[round] || [];
                    if (fixturesForThisRound.length > 0) {
                        fixturesForThisRound.forEach(fixtureString => {
                            const fixtureDisplayItem = document.createElement('div'); // Declare fixtureDisplayItem here
                            fixtureDisplayItem.className = `fixture-item-display`;
                            const match = fixtureString.match(/(.+?)\s*(|)?$/);
                            const [opponentShortCode, homeAwayEmoji, isHomeGame] = [match[1].trim(), match[2] || '', (match[2] === '')];
                            
                            const fdrValue = getFDRValue(teamFullName, opponentShortCode, isHomeGame, fdrType, customRatings);
                            fixtureDisplayItem.textContent = `${opponentShortCode} ${homeAwayEmoji} ${fdrValue !== null ? `(${fdrValue})` : ''}`; 
                            
                            fixtureCell.appendChild(fixtureDisplayItem);
                            fixtureCell.classList.add(fdrValue !== null ? `fdr-${fdrValue}` : 'fdr-na');
                        });
                    } else { fixtureCell.textContent = ''; fixtureCell.classList.add('fdr-na'); }
                    teamsToTargetScheduleGrid.appendChild(fixtureCell);
                });

                const fdrTotalCell = document.createElement('div'); fdrTotalCell.className = 'grid-fixture-cell grid-fdr-total-cell'; fdrTotalCell.textContent = teamData.fdrTotal; teamsToTargetScheduleGrid.appendChild(fdrTotalCell);
            });
        }

        // Function to load and set the user's preferred FDR system
        async function loadAndSetPreferredFDRSystem() {
            const user = auth.currentUser;
            let preferredSystem = 'overall'; // Default
            if (user) {
                const userDocSnap = await getDoc(doc(db, "users", user.uid));
                if (userDocSnap.exists() && userDocSnap.data().preferredFDRSystem) {
                    preferredSystem = userDocSnap.data().preferredFdrSystem; // Corrected: Use preferredFDRSystem
                }
            }
            // Set the global variable
            selectedFDRSystem = preferredSystem;

            // Set the correct radio button
            if (preferredSystem === 'overall' && radioOverallFDR) radioOverallFDR.checked = true;
            else if (preferredSystem === 'homeAway' && radioHomeAwayFDR) radioHomeAwayFDR.checked = true;
            else if (preferredSystem === 'customized' && radioCustomizedFDR) radioCustomizedFDR.checked = true;
            
            displaySelectedFDRSystem(preferredSystem);
        }

        // Function to display the selected FDR system (for FDR section)
        async function displaySelectedFDRSystem(system) {
            selectedFDRSystem = system; // Update global variable

            // Update "Chosen FDR System" text for FDR section
            if (chosenFDRSystemDisplayFDR) {
                const systemName = {
                    'overall': 'Overall FDR',
                    'homeAway': 'Home/Away FDR',
                    'customized': 'Customized FDR'
                }[selectedFDRSystem] || 'Overall FDR';
                chosenFDRSystemDisplayFDR.textContent = `Chosen FDR System: ${systemName}`;
                chosenFDRSystemDisplayFDR.style.display = 'block';
            }

            // Ensure the FDR display container is visible
            if (myControlRoomFDRDisplay) myControlRoomFDRDisplay.style.display = 'block';

            // Hide all specific FDR sections initially
            if (overallFDRSectionControlRoom) overallFDRSectionControlRoom.style.display = 'none';
            if (homeAwayFDRSectionControlRoom) homeAwayFDRSectionControlRoom.style.display = 'none';
            if (customizedFDRSectionControlRoom) customizedFDRSectionControlRoom.style.display = 'none';
            
            // Hide custom ratings specific UI elements when switching away from customized
            if (customRatingsInputGridContainer) customRatingsInputGridContainer.style.display = 'none'; 
            if (saveCustomFDRRatingsButton) saveCustomFDRRatingsButton.style.display = 'none'; 
            if (showCustomRatingsGridButton) showCustomRatingsGridButton.style.display = 'none'; 
            if (customRatingsMessageBox) customRatingsMessageBox.style.display = 'none'; 

            if (selectedFDRSystem === 'overall') {
                if (overallFDRSectionControlRoom) overallFDRSectionControlRoom.style.display = 'block';
                renderScheduleGrid(overallScheduleGrid, globalSeasonSchedule, 'overall');
                renderFDRScale(fdrScaleDisplay, 7);
            } else if (selectedFDRSystem === 'homeAway') {
                if (homeAwayFDRSectionControlRoom) homeAwayFDRSectionControlRoom.style.display = 'block';
                renderScheduleGrid(homeAwayScheduleGrid, globalSeasonSchedule, 'homeAway');
                renderFDRScale(fdrScaleDisplay, 6);
            } else if (selectedFDRSystem === 'customized') {
                if (customizedFDRSectionControlRoom) customizedFDRSectionControlRoom.style.display = 'block';
                const user = auth.currentUser; userCustomFDRRatings = {};
                if (user) {
                    const customFDRDocSnap = await getDoc(doc(db, "users", user.uid, "customFDR", "ratings"));
                    if (customFDRDocSnap.exists()) userCustomFDRRatings = customFDRDocSnap.data();
                }
                renderScheduleGrid(customizedScheduleGrid, globalSeasonSchedule, 'customized', userCustomFDRRatings);
                renderFDRScale(fdrScaleDisplay, 7);
                if (showCustomRatingsGridButton) showCustomRatingsGridButton.style.display = 'block'; // Show the "Customize Ratings" button
            }
        }
        // --- Transfer Planner Functions ---

        /**
         * Fetches the user's actual squad for a given round.
         * For now, it will simulate fetching the initial squad for Round 2.
         * In a real scenario, this would involve calling the manager history API
         * to get the squad at the start of the specified round.
         * @param {string} managerId The SPL Manager ID.
         * @param {number} round The round number to fetch the squad for.
         * @returns {Promise<Array<Object>>} An array of player objects in the squad.
         */
        async function fetchManagerSquadForRound(managerId, round) {
            showTransferPlannerMessage(`Fetching your actual team for Round ${round}...`, 'info');
            try {
                if (globalTeamData.allPlayers.length === 0) {
                    await fetchGlobalFDRData(); 
                }

                const allPlayers = globalTeamData.allPlayers;
                if (allPlayers.length === 0) {
                    throw new Error("No player data available to create a mock squad.");
                }

                const mockSquad = [];
                const usedPlayerIds = new Set();
                const playersByPosition = { 'GKP': [], 'DEF': [], 'MID': [], 'FWD': [] };

                allPlayers.forEach(p => {
                    if (playersByPosition[p.position_short]) {
                        playersByPosition[p.position_short].push(p);
                    }
                });

                // Helper to get a random player of a specific position, ensuring uniqueness
                const getRandomPlayer = (pos, excludeIds = new Set()) => {
                    const availablePlayers = playersByPosition[pos].filter(p => !excludeIds.has(p.id));
                    if (availablePlayers.length > 0) {
                        const player = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
                        excludeIds.add(player.id);
                        return player;
                    }
                    return null;
                };

                // Define the exact slots from your HTML for pitch and bench
                const pitchSlots = [
                    { position: 'GKP', slotId: 1 },
                    { position: 'DEF', slotId: 2 }, { position: 'DEF', slotId: 3 }, { position: 'DEF', slotId: 4 }, { position: 'DEF', slotId: 5 },
                    { position: 'MID', slotId: 6 }, { position: 'MID', slotId: 7 }, { position: 'MID', slotId: 8 }, { position: 'MID', slotId: 9 },
                    { position: 'FWD', slotId: 10 }, { position: 'FWD', slotId: 11 }
                ];
                const benchSlots = [
                    { position: 'BENCH', slotId: 12 }, { position: 'BENCH', slotId: 13 }, { position: 'BENCH', slotId: 14 }, { position: 'BENCH', slotId: 15 }
                ];

                // Fill pitch players based on specific slots
                pitchSlots.forEach(slot => {
                    const player = getRandomPlayer(slot.position, usedPlayerIds);
                    if (player) {
                        mockSquad.push({ ...player, slot_id: slot.slotId, slot_type: 'pitch', buying_price: player.current_price });
                    } else {
                        console.warn(`Could not find a unique ${slot.position} player for pitch slot ${slot.slotId}.`);
                        // Fallback: if no unique player, try to fill with any available player
                        const anyPlayer = getRandomPlayer('GKP', usedPlayerIds) || getRandomPlayer('DEF', usedPlayerIds) || getRandomPlayer('MID', usedPlayerIds) || getRandomPlayer('FWD', usedPlayerIds);
                        if (anyPlayer) mockSquad.push({ ...anyPlayer, slot_id: slot.slotId, slot_type: 'pitch', buying_price: anyPlayer.current_price });
                    }
                });

                // Fill bench players based on specific slots
                benchSlots.forEach(slot => {
                    const player = getRandomPlayer('GKP', usedPlayerIds) || getRandomPlayer('DEF', usedPlayerIds) || getRandomPlayer('MID', usedPlayerIds) || getRandomPlayer('FWD', usedPlayerIds); // Try any position for bench
                    if (player) {
                        mockSquad.push({ ...player, slot_id: slot.slotId, slot_type: 'bench', buying_price: player.current_price });
                    } else {
                        console.warn(`Could not find a unique player for bench slot ${slot.slotId}.`);
                        // Fallback: if still no unique player, just add a random player (could be duplicate)
                        const randomPlayer = allPlayers[Math.floor(Math.random() * allPlayers.length)];
                        mockSquad.push({ ...randomPlayer, slot_id: slot.slotId, slot_type: 'bench', buying_price: randomPlayer.current_price });
                    }
                });

                // Ensure exactly 15 players (should be handled by the above loops if slots are correct)
                if (mockSquad.length !== MAX_SQUAD_SIZE) {
                    console.error(`Generated squad size (${mockSquad.length}) does not match MAX_SQUAD_SIZE (${MAX_SQUAD_SIZE}). Adjusting.`);
                    while (mockSquad.length < MAX_SQUAD_SIZE) {
                        const player = allPlayers[Math.floor(Math.random() * allPlayers.length)];
                        mockSquad.push({ ...player, slot_id: mockSquad.length + 1, slot_type: 'bench', buying_price: player.current_price }); // Assign new slot ID
                    }
                    while (mockSquad.length > MAX_SQUAD_SIZE) {
                        mockSquad.pop(); // Remove excess players
                    }
                }

                showTransferPlannerMessage(`Team loaded for Round ${round}.`, 'success');
                return mockSquad;

            } catch (error) {
                showTransferPlannerMessage(`Failed to load team for Round ${round}: ${error.message}`, 'error');
                console.error("Error fetching manager squad:", error);
                return [];
            }
        }

        /**
         * Calculates the selling price of a player based on FPL rules (modified for SPL).
         * For every 0.2m price increase, there's a 0.1m profit.
         * @param {number} buyingPrice The price the player was bought for (e.g., 5.0).
         * @param {number} currentMarketPrice The player's current market price (e.g., 5.5).
         * @returns {number} The calculated selling price.
         */
        function calculateSellingPrice(buyingPrice, currentMarketPrice) {
            if (currentMarketPrice <= buyingPrice) {
                return currentMarketPrice;
            }
            const profit = currentMarketPrice - buyingPrice; // e.g., 0.5
            const profitIncrements = Math.floor(profit / 0.2); // e.g., Math.floor(0.5 / 0.2) = Math.floor(2.5) = 2
            const sellingProfit = profitIncrements * 0.1; // e.g., 2 * 0.1 = 0.2
            return buyingPrice + sellingProfit; // e.g., 5.0 + 0.2 = 5.2
        }

        /**
         * Renders a player card HTML element.
         * @param {Object} player The player data object.
         * @param {number} currentRound The current planning round for opponent display.
         * @param {boolean} showActions Whether to show remove/move to bench icons.
         * @returns {HTMLElement} The player card div.
         */
        function renderPlayerCard(player, currentRound, showActions = false) {
            const playerCard = document.createElement('div');
            playerCard.className = 'player-card';
            playerCard.setAttribute('draggable', true);
            playerCard.dataset.playerId = player.id;
            playerCard.dataset.currentPrice = player.current_price;
            playerCard.dataset.buyingPrice = player.buying_price; 
            playerCard.dataset.position = player.position_short; // Add position to dataset for validation

            // Placeholder image for player
            const playerImageSrc = `https://placehold.co/50x50/cccccc/000000?text=${player.position_short}`;
            // Placeholder image for team logo
            const teamLogoSrc = `https://placehold.co/20x20/007bff/ffffff?text=${player.team_short_name}`;

            // Get opponent and FDR for the current planning round
            let opponentDisplay = 'N/A';
            let fdrValue = null;
            const roundName = `R${currentRound}`;
            const teamFixtures = globalSeasonSchedule.fixtures[player.team_name];
            if (teamFixtures && teamFixtures[roundName] && teamFixtures[roundName].length > 0) {
                const fixtureString = teamFixtures[roundName][0]; // Assuming one fixture per round
                const match = fixtureString.match(/(.+?)\s*(|)?$/);
                const [opponentShortCode, homeAwayEmoji, isHomeGame] = [match[1].trim(), match[2] || '', (match[2] === '')];
                opponentDisplay = `${opponentShortCode} ${homeAwayEmoji}`;
                fdrValue = getFDRValue(player.team_name, opponentShortCode, isHomeGame, selectedFDRSystem, userCustomFDRRatings);
            }

            playerCard.innerHTML = `
                <img class="player-image" src="${playerImageSrc}" alt="${player.name}">
                <div class="player-name">${player.name}</div>
                <div class="player-details">
                    ${player.position_short} <img class="team-logo" src="${teamLogoSrc}" alt="${player.team_short_name}">
                </div>
                <div class="player-price">${player.current_price.toFixed(1)}m</div>
                <div class="player-opponent">
                    ${opponentDisplay} 
                    ${fdrValue !== null ? `<span class="fdr-value-display fdr-${fdrValue}">${fdrValue}</span>` : ''}
                </div>
            `;

            if (showActions) {
                const playerActions = document.createElement('div');
                playerActions.className = 'player-actions';

                const removeIcon = document.createElement('div');
                removeIcon.className = 'action-icon remove-player';
                removeIcon.innerHTML = '&times;'; // Red 'X' icon
                removeIcon.title = 'Remove Player';
                removeIcon.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent dragstart if clicked
                    removePlayerFromSquad(player.id);
                });
                playerActions.appendChild(removeIcon);

                const moveIcon = document.createElement('div');
                moveIcon.className = 'action-icon move-player';
                moveIcon.innerHTML = player.slot_type === 'pitch' ? '&#8595;' : '&#8593;'; // Down arrow for pitch, up for bench
                moveIcon.title = player.slot_type === 'pitch' ? 'Move to Bench' : 'Move to Pitch';
                moveIcon.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent dragstart if clicked
                    togglePlayerPosition(player.id);
                });
                playerActions.appendChild(moveIcon);

                playerCard.appendChild(playerActions);
            }

            return playerCard;
        }

        /**
         * Renders the current squad on the pitch and bench.
         * @param {Array<Object>} squad The array of player objects in the current squad.
         * @param {number} currentRound The current planning round for opponent display.
         */
        function renderSquad(squad, currentRound) {
            // Clear all slots first
            document.querySelectorAll('.player-slot').forEach(slot => {
                slot.innerHTML = '';
                slot.classList.remove('has-player');
                slot.dataset.playerId = ''; // Clear data attribute
                slot.dataset.playerPos = ''; // Clear player position from slot
            });

            // Render Players into their assigned slots
            squad.forEach(player => {
                const slotElement = document.querySelector(`.player-slot[data-slot-id="${player.slot_id}"][data-slot-type="${player.slot_type}"]`);
                if (slotElement) {
                    const playerCard = renderPlayerCard(player, currentRound, true); // Show actions for squad players
                    slotElement.appendChild(playerCard);
                    slotElement.classList.add('has-player');
                    slotElement.dataset.playerId = player.id;
                    slotElement.dataset.playerPos = player.position_short;
                } else {
                    console.warn(`Could not find slot for player: ${player.name} (ID: ${player.id}) at slot ID ${player.slot_id} type ${player.slot_type}.`);
                }
            });
            updateTransferSummary();
        }

        /**
         * Renders the list of available players in the sidebar.
         * @param {Array<Object>} players The array of player objects to display.
         */
        function renderPlayerList(players) {
            playerList.innerHTML = '';
            players.forEach(player => {
                const playerCard = renderPlayerCard(player, currentPlanningRound, false); // No actions for list players
                playerCard.classList.add('player-card-list-item'); // Add a specific class for list items
                playerList.appendChild(playerCard);
            });
        }

        /**
         * Filters and renders the player list based on the active filter and search input.
         */
        function filterAndRenderPlayerList() {
            let playersToDisplay = globalTeamData.allPlayers;

            // Filter out players already in the current squad
            const squadPlayerIds = new Set(currentSquad.map(p => p.id));
            playersToDisplay = playersToDisplay.filter(p => !squadPlayerIds.has(p.id));

            // Apply position filter
            if (activePlayerFilter !== 'ALL') {
                playersToDisplay = playersToDisplay.filter(p => p.position_short === activePlayerFilter);
            }

            // Apply search filter
            const searchTerm = playerSearchInput.value.toLowerCase();
            if (searchTerm) {
                playersToDisplay = playersToDisplay.filter(p => 
                    p.name.toLowerCase().includes(searchTerm) || 
                    p.team_name.toLowerCase().includes(searchTerm) ||
                    p.team_short_name.toLowerCase().includes(searchTerm)
                );
            }
            
            // Sort players (e.g., by total points descending)
            playersToDisplay.sort((a, b) => b.total_points - a.total_points);

            filteredPlayers = playersToDisplay; // Update global filteredPlayers
            renderPlayerList(filteredPlayers);
        }

        /**
         * Updates the transfer summary display (funds, free transfers, points hit).
         */
        function updateTransferSummary() {
            // Recalculate funds and hits based on pending transfers
            let totalCost = 0;
            let transfersMadeCount = 0;
            
            // Calculate total cost and transfers made from pendingTransfers
            // This is a simplified calculation. A full implementation would track
            // actual buying prices for owned players and selling prices based on profit.
            pendingTransfers.forEach(transfer => {
                transfersMadeCount++;
                if (transfer.type === 'in') {
                    totalCost += transfer.player.current_price;
                } else if (transfer.type === 'out') {
                    // For 'out' transfers, we need the selling price
                    // If the player was part of the original squad, use their buying_price
                    // If they were added in a previous planning round, use their buying_price from that round
                    const playerInSquad = currentSquad.find(p => p.id === transfer.player.id);
                    const sellingPrice = playerInSquad ? calculateSellingPrice(playerInSquad.buying_price, transfer.player.current_price) : transfer.player.current_price;
                    totalCost -= sellingPrice;
                }
            });

            // Calculate free transfers and hits
            let actualFreeTransfers = currentFreeTransfers;
            let actualPointsHit = 0;

            if (transfersMadeCount > actualFreeTransfers) {
                actualPointsHit = (transfersMadeCount - actualFreeTransfers) * POINTS_HIT_PER_TRANSFER;
            }

            currentPlanningRoundDisplay.textContent = currentPlanningRound;
            freeTransfersDisplay.textContent = actualFreeTransfers - transfersMadeCount < 0 ? 0 : actualFreeTransfers - transfersMadeCount;
            pointsHitDisplay.textContent = actualPointsHit;
            fundsDisplay.textContent = `${(currentFunds - totalCost).toFixed(1)}m`;
        }

        /**
         * Validates the current squad formation against FPL rules.
         * @param {Array<Object>} squad The current squad array.
         * @returns {Object} { isValid: boolean, message: string }
         */
        function validateSquadFormation(squad) {
            const pitchPlayers = squad.filter(p => p.slot_type === 'pitch');
            const benchPlayers = squad.filter(p => p.slot_type === 'bench');

            // Rule 1: Total players must be 15
            if (squad.length !== MAX_SQUAD_SIZE) {
                return { isValid: false, message: `Squad must have exactly ${MAX_SQUAD_SIZE} players (11 pitch, 4 bench). Current: ${squad.length}` };
            }

            // Rule 2: Positional limits (total squad)
            const squadPositionCounts = { 'GKP': 0, 'DEF': 0, 'MID': 0, 'FWD': 0 };
            squad.forEach(p => squadPositionCounts[p.position_short]++);

            // Max players per position in total squad (common FPL rules)
            if (squadPositionCounts['GKP'] > 2) return { isValid: false, message: "Squad: Max 2 Goalkeepers." };
            if (squadPositionCounts['DEF'] > 5) return { isValid: false, message: "Squad: Max 5 Defenders." };
            if (squadPositionCounts['MID'] > 5) return { isValid: false, message: "Squad: Max 5 Midfielders." };
            if (squadPositionCounts['FWD'] > 3) return { isValid: false, message: "Squad: Max 3 Forwards." };

            // Rule 3: Pitch formation rules (1 GKP, at least 3 DEF, at least 1 FWD, total 11)
            const pitchPositionCounts = { 'GKP': 0, 'DEF': 0, 'MID': 0, 'FWD': 0 };
            pitchPlayers.forEach(p => pitchPositionCounts[p.position_short]++);

            if (pitchPlayers.length !== 11) {
                return { isValid: false, message: `Pitch: Must have exactly 11 players. Current: ${pitchPlayers.length}` };
            }
            if (benchPlayers.length !== 4) {
                return { isValid: false, message: `Bench: Must have exactly 4 players. Current: ${benchPlayers.length}` };
            }

            if (pitchPositionCounts['GKP'] !== PITCH_MIN_POSITION_COUNTS['GKP']) {
                return { isValid: false, message: `Pitch: Must have exactly ${PITCH_MIN_POSITION_COUNTS['GKP']} Goalkeeper.` };
            }
            if (pitchPositionCounts['DEF'] < PITCH_MIN_POSITION_COUNTS['DEF']) {
                return { isValid: false, message: `Pitch: Must have at least ${PITCH_MIN_POSITION_COUNTS['DEF']} Defenders.` };
            }
            if (pitchPositionCounts['FWD'] < PITCH_MIN_POSITION_COUNTS['FWD']) {
                return { isValid: false, message: `Pitch: Must have at least ${PITCH_MIN_POSITION_COUNTS['FWD']} Forward.` };
            }
            // Midfielders don't have a minimum on pitch, as long as total 11 is met and others are valid.

            // Rule 4: Max 3 players from one team
            const teamCounts = {};
            squad.forEach(p => {
                teamCounts[p.team_id] = (teamCounts[p.team_id] || 0) + 1;
                if (teamCounts[p.team_id] > MAX_PLAYERS_PER_TEAM) {
                    return { isValid: false, message: `You can only have a maximum of ${MAX_PLAYERS_PER_TEAM} players from one team.` };
                }
            });

            return { isValid: true, message: "Squad is valid." };
        }

        /**
         * Initializes the Transfer Planner when it's opened.
         * Fetches the initial squad, sets up UI, and renders.
         */
        async function initializeTransferPlanner() {
            showTransferPlannerMessage('Loading Transfer Planner...', 'info');
            currentPlanningRound = INITIAL_PLANNING_ROUND;
            currentFreeTransfers = 1; // Start with 1 free transfer for Round 2
            currentPointsHit = 0;
            pendingTransfers = []; // Clear pending transfers

            if (!currentManagerId) {
                showTransferPlannerMessage('Manager ID not found. Please log in.', 'error');
                return;
            }

            // Fetch initial squad for Round 2 (mocked for now)
            currentSquad = await fetchManagerSquadForRound(currentManagerId, INITIAL_PLANNING_ROUND);
            
            // Calculate initial funds based on the mock squad's value
            currentFunds = currentSquad.reduce((sum, player) => sum + player.current_price, 0); // Sum of current prices
            currentFunds += 0.0; // Add some initial bank, e.g., 0.0m

            renderSquad(currentSquad, currentPlanningRound);
            filterAndRenderPlayerList(); // Render all players initially
            updateTransferSummary();
            showTransferPlannerMessage('Transfer Planner ready!', 'success');
        }

        /**
         * Handles removing a player from the squad.
         * @param {number} playerId The ID of the player to remove.
         */
        function removePlayerFromSquad(playerId) {
            const playerToRemoveIndex = currentSquad.findIndex(p => p.id === playerId);
            if (playerToRemoveIndex !== -1) {
                const playerToRemove = currentSquad[playerToRemoveIndex];
                
                // Add to pending transfers as an 'out' transfer
                pendingTransfers.push({ type: 'out', player: playerToRemove });

                currentSquad.splice(playerToRemoveIndex, 1); // Remove player from squad
                renderSquad(currentSquad, currentPlanningRound); // Re-render to show empty slot
                showTransferPlannerMessage(`${playerToRemove.name} removed. Drag a new player into the empty slot.`, 'info');
                filterAndRenderPlayerList(); // Re-render player list (might need to show removed player if they are now available)
            }
            updateTransferSummary();
        }

        /**
         * Toggles a player's position between pitch and bench.
         * @param {number} playerId The ID of the player to move.
         */
        function togglePlayerPosition(playerId) {
            const playerToMove = currentSquad.find(p => p.id === playerId);
            if (!playerToMove) return;

            const currentSlotType = playerToMove.slot_type;
            const currentPosition = playerToMove.position_short;

            // Find an empty slot in the target area
            let targetSlotElement = null;
            let newSlotType = '';
            let newSlotId = null;

            if (currentSlotType === 'pitch') {
                // Try to move to bench
                const emptyBenchSlots = Array.from(benchArea.querySelectorAll('.player-slot:not(.has-player)'));
                if (emptyBenchSlots.length > 0) {
                    targetSlotElement = emptyBenchSlots[0];
                    newSlotType = 'bench';
                    newSlotId = parseInt(targetSlotElement.dataset.slotId);
                } else {
                    showTransferPlannerMessage('Bench is full. Cannot move player to bench directly.', 'warning');
                    return;
                }
            } else { // currentSlotType === 'bench'
                // Try to move to pitch
                const emptyPitchSlots = Array.from(pitchArea.querySelectorAll(`.player-slot[data-position="${currentPosition}"]:not(.has-player)`));
                if (emptyPitchSlots.length > 0) {
                    targetSlotElement = emptyPitchSlots[0];
                    newSlotType = 'pitch';
                    newSlotId = parseInt(targetSlotElement.dataset.slotId);
                } else {
                    showTransferPlannerMessage(`No empty pitch slot for a ${currentPosition}.`, 'warning');
                    return;
                }
            }

            // Temporarily update player's slot for validation
            const originalSlotType = playerToMove.slot_type;
            const originalSlotId = playerToMove.slot_id;
            playerToMove.slot_type = newSlotType;
            playerToMove.slot_id = newSlotId;

            const validationResult = validateSquadFormation(currentSquad);
            if (!validationResult.isValid) {
                // Revert changes if invalid
                playerToMove.slot_type = originalSlotType;
                playerToMove.slot_id = originalSlotId;
                showTransferPlannerMessage(`Cannot move ${playerToMove.name}: ${validationResult.message}`, 'error');
                return;
            }

            // If valid, update the player in the currentSquad
            playerToMove.slot_type = newSlotType;
            playerToMove.slot_id = newSlotId;

            // No need to add to pendingTransfers for pitch/bench swaps, as they don't affect funds/hits
            renderSquad(currentSquad, currentPlanningRound);
            showTransferPlannerMessage(`${playerToMove.name} moved to ${newSlotType}.`, 'info');
            updateTransferSummary();
        }

        // --- Drag and Drop Logic ---
        let draggedPlayerId = null;
        let draggedPlayerSourceSlot = null; // To track if dragging from list or from pitch/bench

        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('player-card')) {
                draggedPlayerId = parseInt(e.target.dataset.playerId);
                // Check if dragging from a slot or from the player list
                if (e.target.closest('.player-slot')) {
                    draggedPlayerSourceSlot = e.target.closest('.player-slot');
                } else if (e.target.closest('#playerList')) {
                    draggedPlayerSourceSlot = 'playerList';
                }
                e.dataTransfer.setData('text/plain', draggedPlayerId);
                e.dataTransfer.effectAllowed = 'move';
            }
        });

        document.querySelectorAll('.player-slot').forEach(slot => {
            slot.addEventListener('dragover', (e) => {
                e.preventDefault(); // Allow drop
                e.dataTransfer.dropEffect = 'move';
                slot.classList.add('drag-over');
            });

            slot.addEventListener('dragleave', (e) => {
                slot.classList.remove('drag-over');
            });

            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                slot.classList.remove('drag-over');

                const droppedPlayerId = parseInt(e.dataTransfer.getData('text/plain'));
                const droppedPlayer = globalTeamData.allPlayers.find(p => p.id === droppedPlayerId);
                if (!droppedPlayer) {
                    showTransferPlannerMessage('Invalid player dropped.', 'error');
                    return;
                }

                const targetSlot = e.currentTarget;
                const targetSlotId = parseInt(targetSlot.dataset.slotId);
                const targetSlotType = targetSlot.dataset.slotType; // 'pitch' or 'bench'
                const targetSlotPosition = targetSlot.dataset.position; // 'GKP', 'DEF', etc.

                const playerInTargetSlotId = targetSlot.dataset.playerId ? parseInt(targetSlot.dataset.playerId) : null;
                const playerInTargetSlot = playerInTargetSlotId ? currentSquad.find(p => p.id === playerInTargetSlotId) : null;

                // Scenario 1: Dragging from Player List to an empty slot
                if (draggedPlayerSourceSlot === 'playerList' && !playerInTargetSlot) {
                    // Check if the position matches
                    if (targetSlotType === 'pitch' && droppedPlayer.position_short !== targetSlotPosition) {
                        showTransferPlannerMessage(`Cannot place a ${droppedPlayer.position_short} into a ${targetSlotPosition} slot.`, 'error');
                        return;
                    }
                    
                    // Create a temporary squad for validation
                    const tempSquad = [...currentSquad];
                    const newPlayerForSquad = { 
                        ...droppedPlayer, 
                        slot_id: targetSlotId, 
                        slot_type: targetSlotType, 
                        buying_price: droppedPlayer.current_price // New players are bought at current price
                    };
                    tempSquad.push(newPlayerForSquad);

                    const validationResult = validateSquadFormation(tempSquad);
                    if (!validationResult.isValid) {
                        showTransferPlannerMessage(`Cannot add ${droppedPlayer.name}: ${validationResult.message}`, 'error');
                        return;
                    }

                    // If valid, apply the transfer
                    currentSquad.push(newPlayerForSquad);
                    pendingTransfers.push({ type: 'in', player: newPlayerForSquad, newSlotId: targetSlotId, newSlotType: targetSlotType });
                    showTransferPlannerMessage(`${droppedPlayer.name} added.`, 'success');

                }
                // Scenario 2: Dragging from Player List to a slot with a player (swap/replace)
                else if (draggedPlayerSourceSlot === 'playerList' && playerInTargetSlot) {
                    // Check if positions match for pitch slots
                    if (targetSlotType === 'pitch' && droppedPlayer.position_short !== targetSlotPosition) {
                        showTransferPlannerMessage(`Cannot swap a ${droppedPlayer.position_short} with a ${targetSlotPosition}.`, 'error');
                        return;
                    }

                    // Create a temporary squad for validation
                    const tempSquad = currentSquad.filter(p => p.id !== playerInTargetSlot.id); // Remove old player
                    const newPlayerForSquad = { 
                        ...droppedPlayer, 
                        slot_id: targetSlotId, 
                        slot_type: targetSlotType, 
                        buying_price: droppedPlayer.current_price 
                    };
                    tempSquad.push(newPlayerForSquad); // Add new player

                    const validationResult = validateSquadFormation(tempSquad);
                    if (!validationResult.isValid) {
                        showTransferPlannerMessage(`Cannot swap: ${validationResult.message}`, 'error');
                        return;
                    }

                    // If valid, apply the swap
                    removePlayerFromSquad(playerInTargetSlot.id); // This will add to pendingTransfers as 'out'
                    currentSquad.push(newPlayerForSquad); // Add new player
                    pendingTransfers.push({ type: 'in', player: newPlayerForSquad, newSlotId: targetSlotId, newSlotType: targetSlotType });
                    showTransferPlannerMessage(`${playerInTargetSlot.name} replaced by ${droppedPlayer.name}.`, 'success');
                }
                // Scenario 3: Dragging from one slot to another (pitch to bench, bench to pitch, or within pitch/bench)
                else if (draggedPlayerSourceSlot && draggedPlayerSourceSlot !== 'playerList') {
                    const sourceSlotId = parseInt(draggedPlayerSourceSlot.dataset.slotId);
                    const sourceSlotType = draggedPlayerSourceSlot.dataset.slotType;

                    const playerToMove = currentSquad.find(p => p.id === droppedPlayerId);
                    if (!playerToMove) return;

                    // If dropping onto self, do nothing
                    if (playerToMove.slot_id === targetSlotId && playerToMove.slot_type === targetSlotType) {
                        return;
                    }

                    // If dropping onto an empty slot
                    if (!playerInTargetSlot) {
                        // Check position compatibility for pitch slots
                        if (targetSlotType === 'pitch' && playerToMove.position_short !== targetSlotPosition) {
                            showTransferPlannerMessage(`Cannot move a ${playerToMove.position_short} to a ${targetSlotPosition} slot.`, 'error');
                            return;
                        }

                        // Temporarily update player's slot for validation
                        const originalPlayerSlotId = playerToMove.slot_id;
                        const originalPlayerSlotType = playerToMove.slot_type;
                        playerToMove.slot_id = targetSlotId;
                        playerToMove.slot_type = targetSlotType;

                        const validationResult = validateSquadFormation(currentSquad);
                        if (!validationResult.isValid) {
                            playerToMove.slot_id = originalPlayerSlotId; // Revert
                            playerToMove.slot_type = originalPlayerSlotType; // Revert
                            showTransferPlannerMessage(`Cannot move ${playerToMove.name}: ${validationResult.message}`, 'error');
                            return;
                        }

                        // If valid, apply the move
                        playerToMove.slot_id = targetSlotId;
                        playerToMove.slot_type = targetSlotType;
                        showTransferPlannerMessage(`${playerToMove.name} moved.`, 'success');
                    }
                    // If dropping onto a slot with another player (swap)
                    else {
                        // Check position compatibility for pitch slots for both players
                        if (targetSlotType === 'pitch' && playerToMove.position_short !== targetSlotPosition) {
                            showTransferPlannerMessage(`Cannot swap ${playerToMove.name} (${playerToMove.position_short}) with ${playerInTargetSlot.name} (${playerInTargetSlot.position_short}) in this pitch slot.`, 'error');
                            return;
                        }
                        if (sourceSlotType === 'pitch' && playerInTargetSlot.position_short !== draggedPlayerSourceSlot.dataset.position) {
                             // This case is implicitly handled by the previous check if targetSlotType is pitch
                             // But good to keep in mind for general swaps
                        }

                        // Perform a swap: temporarily update both players' slots for validation
                        const originalPlayerToMoveSlotId = playerToMove.slot_id;
                        const originalPlayerToMoveSlotType = playerToMove.slot_type;
                        const originalPlayerInTargetSlotId = playerInTargetSlot.slot_id;
                        const originalPlayerInTargetSlotType = playerInTargetSlot.slot_type;

                        playerToMove.slot_id = targetSlotId;
                        playerToMove.slot_type = targetSlotType;
                        playerInTargetSlot.slot_id = sourceSlotId;
                        playerInTargetSlot.slot_type = sourceSlotType;

                        const validationResult = validateSquadFormation(currentSquad);
                        if (!validationResult.isValid) {
                            // Revert changes if invalid
                            playerToMove.slot_id = originalPlayerToMoveSlotId;
                            playerToMove.slot_type = originalPlayerToMoveSlotType;
                            playerInTargetSlot.slot_id = originalPlayerInTargetSlotId;
                            playerInTargetSlot.slot_type = originalPlayerInTargetSlotType;
                            showTransferPlannerMessage(`Cannot swap: ${validationResult.message}`, 'error');
                            return;
                        }

                        // If valid, apply the swap
                        playerToMove.slot_id = targetSlotId;
                        playerToMove.slot_type = targetSlotType;
                        playerInTargetSlot.slot_id = sourceSlotId;
                        playerInTargetSlot.slot_type = sourceSlotType;
                        showTransferPlannerMessage(`${playerToMove.name} swapped with ${playerInTargetSlot.name}.`, 'success');
                    }
                }
                renderSquad(currentSquad, currentPlanningRound);
                updateTransferSummary();
            });
        });
        // --- Event Listeners ---

        document.querySelectorAll('input[name="fdrSystem"]').forEach(radio => { radio.addEventListener('change', async () => {
            displaySelectedFDRSystem(radio.value);
            if (teamsToTargetContainer.style.display === 'flex') {
                if (radio.value === 'customized') {
                    const user = auth.currentUser; userCustomFDRRatings = {};
                    if (user) {
                        const customFDRDocSnap = await getDoc(doc(db, "users", user.uid, "customFDR", "ratings"));
                        if (customFDRDocSnap.exists()) userCustomFDRRatings = customFDRDocSnap.data();
                    }
                }
                renderTeamsToTargetScheduleGrid(globalSeasonSchedule, radio.value, userCustomFDRRatings);
            }
        }); });

        if (saveFDRSystemButton) {
            saveFDRSystemButton.addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) { showControlRoomMessage("You must be logged in to save your preferred FDR system.", "error"); return; }

                try {
                    await setDoc(doc(db, "users", user.uid), { preferredFDRSystem: selectedFDRSystem }, { merge: true });
                    showSaveFDRSystemMessage("Your FDR System is Saved!", "success");
                } catch (error) {
                    showControlRoomMessage(`Failed to save FDR system: ${error.message}`, "error");
                }
            });
        }

        if (showFDRButton) { 
            showFDRButton.addEventListener('click', () => { 
                if (fdrSystemsContainer) fdrSystemsContainer.style.display = 'flex'; 
                if (teamsToTargetContainer) teamsToTargetContainer.style.display = 'none'; 
                if (transferPlannerContainer) transferPlannerContainer.style.display = 'none'; 
                loadAndSetPreferredFDRSystem(); 
            }); 
        }

        if (showTeamsToTargetButton) {
            showTeamsToTargetButton.addEventListener('click', async () => { 
                if (fdrSystemsContainer) fdrSystemsContainer.style.display = 'none'; 
                if (teamsToTargetContainer) teamsToTargetContainer.style.display = 'flex'; 
                if (transferPlannerContainer) transferPlannerContainer.style.display = 'none'; 
                
                if (chosenFDRSystemDisplayTeamsToTarget) {
                    const systemName = {
                        'overall': 'Overall FDR',
                        'homeAway': 'Home/Away FDR',
                        'customized': 'Customized FDR'
                    }[selectedFDRSystem] || 'Overall FDR';
                    chosenFDRSystemDisplayTeamsToTarget.textContent = `Chosen FDR System: ${systemName}`;
                    chosenFDRSystemDisplayTeamsToTarget.style.display = 'block';
                }

                if (selectedFDRSystem === 'customized') {
                    const user = auth.currentUser; userCustomFDRRatings = {};
                    if (user) {
                        const customFDRDocSnap = await getDoc(doc(db, "users", user.uid, "customFDR", "ratings"));
                        if (customFDRDocSnap.exists()) userCustomFDRRatings = customFDRDocSnap.data();
                    }
                }
                renderTeamsToTargetScheduleGrid(globalSeasonSchedule, selectedFDRSystem, userCustomFDRRatings);
            });
        }

        // NEW: Transfer Planner Button Click
        if (showTransferPlannerButton) {
            showTransferPlannerButton.addEventListener('click', async () => {
                if (fdrSystemsContainer) fdrSystemsContainer.style.display = 'none';
                if (teamsToTargetContainer) teamsToTargetContainer.style.display = 'none';
                if (transferPlannerContainer) transferPlannerContainer.style.display = 'grid'; // Use grid for planner layout
                await initializeTransferPlanner(); // Initialize the planner
            });
        }

        if (showCustomRatingsGridButton) {
            showCustomRatingsGridButton.addEventListener('click', () => {
                if (customRatingsInputGridContainer) customRatingsInputGridContainer.style.display = 'block';
                if (saveCustomFDRRatingsButton) saveCustomFDRRatingsButton.style.display = 'block';
                renderCustomRatingsInputGrid(document.getElementById('customRatingsGrid'), globalSeasonSchedule.teams, userCustomFDRRatings);
                if (showCustomRatingsGridButton) showCustomRatingsGridButton.style.display = 'none'; 
                if (customRatingsMessageBox) customRatingsMessageBox.style.display = 'none'; 
            });
        }

        if (saveCustomFDRRatingsButton) {
            saveCustomFDRRatingsButton.addEventListener('click', async () => {
                const user = auth.currentUser; 
                if (!user) { showCustomRatingsMessage("You must be logged in to save custom ratings.", "error"); return; }
                
                const newCustomRatings = {}; 
                let allRatingsFilled = true;
                const customSelects = document.getElementById('customRatingsGrid').querySelectorAll('select');
                
                if (customSelects.length === 0) { showCustomRatingsMessage("No ratings to save. Please generate the grid first.", "error"); return; }
                
                customSelects.forEach(select => {
                    const [teamFullName, homeAway, value] = [select.dataset.teamFullName, select.dataset.homeAway, parseInt(select.value, 10)];
                    if (isNaN(value) || value < 1 || value > 7) { 
                        allRatingsFilled = false; 
                        return; 
                    }
                    newCustomRatings[`${teamFullName}_${homeAway}`] = value;
                });

                if (!allRatingsFilled) { 
                    showCustomRatingsMessage("Please rate all fixtures to save your ratings.", "error"); 
                    return; 
                }

                try {
                    await setDoc(doc(db, "users", user.uid, "customFDR", "ratings"), newCustomRatings);
                    userCustomFDRRatings = newCustomRatings; 
                    showCustomRatingsMessage("Your ratings have been saved!", "success");
                    
                    if (customRatingsInputGridContainer) customRatingsInputGridContainer.style.display = 'none';
                    if (saveCustomFDRRatingsButton) saveCustomFDRRatingsButton.style.display = 'none';
                    
                    if (showCustomRatingsGridButton) showCustomRatingsGridButton.style.display = 'block';

                    renderScheduleGrid(customizedScheduleGrid, globalSeasonSchedule, 'customized', userCustomFDRRatings);
                    if (teamsToTargetContainer.style.display === 'flex' && selectedFDRSystem === 'customized') {
                        renderTeamsToTargetScheduleGrid(globalSeasonSchedule, 'customized', userCustomFDRRatings);
                    }

                } catch (error) { 
                    showCustomRatingsMessage(`Failed to save custom ratings: ${error.message}`, "error"); 
                }
            });
        }

        if (roundsToShowSlider) { 
            roundsToShowSlider.addEventListener('input', (e) => {
                roundsToShow = parseInt(e.target.value, 10);
                if (roundsToShowValueSpan) roundsToShowValueSpan.textContent = roundsToShow;
                if (fdrSystemsContainer.style.display === 'flex') {
                    displaySelectedFDRSystem(selectedFDRSystem); 
                }
            });
        }

        if (roundsToShowTeamsToTargetSlider) { 
            roundsToShowTeamsToTargetSlider.addEventListener('input', (e) => {
                roundsToShow = parseInt(e.target.value, 10); 
                if (roundsToShowValueTeamsToTargetSpan) roundsToShowValueTeamsToTargetSpan.textContent = roundsToShow;
                if (teamsToTargetContainer.style.display === 'flex') {
                    renderTeamsToTargetScheduleGrid(globalSeasonSchedule, selectedFDRSystem, userCustomFDRRatings);
                }
            });
        }

        // Transfer Planner Controls
        if (prevRoundButton) { // Check if element exists before adding listener
            prevRoundButton.addEventListener('click', () => {
                if (currentPlanningRound > INITIAL_PLANNING_ROUND) {
                    currentPlanningRound--;
                    // Logic to revert transfers for the previous round, or load a previous plan state
                    showTransferPlannerMessage(`Moved to Round ${currentPlanningRound}`, 'info');
                    renderSquad(currentSquad, currentPlanningRound); // Re-render squad with new opponents
                    filterAndRenderPlayerList(); // Update player list as well
                } else {
                    showTransferPlannerMessage('Cannot go before the initial planning round.', 'warning');
                }
                updateTransferSummary();
            });
        }

        if (nextRoundButton) { // Check if element exists before adding listener
            nextRoundButton.addEventListener('click', () => {
                if (currentPlanningRound < globalSeasonSchedule.rounds.length) { // Max round is 34
                    currentPlanningRound++;
                    // Logic to apply current round's planned transfers and prepare for next round
                    // For now, just advance round and re-render opponents
                    showTransferPlannerMessage(`Moved to Round ${currentPlanningRound}`, 'info');
                    renderSquad(currentSquad, currentPlanningRound); // Re-render squad with new opponents
                    filterAndRenderPlayerList(); // Update player list as well
                } else {
                    showTransferPlannerMessage('Reached the last round of the season.', 'warning');
                }
                updateTransferSummary();
            });
        }

        if (savePlanButton) { // Check if element exists before adding listener
            savePlanButton.addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) {
                    showTransferPlannerMessage('You must be logged in to save a plan.', 'error');
                    return;
                }

                const planName = prompt("Enter a name for your transfer plan:");
                if (!planName || planName.trim() === "") {
                    showTransferPlannerMessage('Plan name cannot be empty.', 'warning');
                    return;
                }

                // Create a simplified plan object for now
                const planData = {
                    name: planName,
                    // Store the current state of the squad, including slot_id and slot_type
                    squadState: currentSquad.map(p => ({ 
                        id: p.id, 
                        slot_id: p.slot_id, 
                        slot_type: p.slot_type, 
                        buying_price: p.buying_price 
                    })),
                    currentRound: currentPlanningRound,
                    currentFreeTransfers: currentFreeTransfers,
                    currentPointsHit: currentPointsHit,
                    currentFunds: currentFunds,
                    pendingTransfers: pendingTransfers.map(t => ({ 
                        type: t.type, 
                        playerId: t.player.id, 
                        newSlotId: t.newSlotId, 
                        newSlotType: t.newSlotType 
                    })), // Store simplified pending transfers
                    createdAt: serverTimestamp(),
                    lastModified: serverTimestamp()
                };

                try {
                    // Save to a subcollection under the user's document
                    await setDoc(doc(db, `users/${user.uid}/transferPlans`, planName), planData);
                    showTransferPlannerMessage(`Plan "${planName}" saved successfully!`, 'success');
                } catch (error) {
                    console.error("Error saving plan:", error);
                    showTransferPlannerMessage(`Failed to save plan: ${error.message}`, 'error');
                }
            });
        }

        if (loadPlanButton) { // Check if element exists before adding listener
            loadPlanButton.addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) {
                    showTransferPlannerMessage('You must be logged in to load a plan.', 'error');
                    return;
                }

                try {
                    const plansCollectionRef = collection(db, `users/${user.uid}/transferPlans`);
                    const querySnapshot = await getDocs(plansCollectionRef);

                    if (querySnapshot.empty) {
                        showTransferPlannerMessage('No saved plans found.', 'info');
                        return;
                    }

                    let planList = "Available Plans:\n";
                    const plans = [];
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        plans.push({ id: doc.id, name: data.name, data: data });
                        planList += `- ${data.name}\n`;
                    });

                    const planToLoadName = prompt(planList + "\nEnter the name of the plan to load:");
                    if (!planToLoadName || planToLoadName.trim() === "") {
                        showTransferPlannerMessage('No plan selected.', 'warning');
                        return;
                    }

                    const selectedPlan = plans.find(p => p.name === planToLoadName);
                    if (selectedPlan) {
                        // Reconstruct the squad from the saved plan's squadState
                        currentSquad = selectedPlan.data.squadState.map(p => {
                            const playerDetails = globalTeamData.allPlayers.find(ap => ap.id === p.id);
                            // Ensure playerDetails is found before spreading
                            if (playerDetails) {
                                return { ...playerDetails, slot_id: p.slot_id, slot_type: p.slot_type, buying_price: p.buying_price };
                            } else {
                                console.warn(`Player with ID ${p.id} not found in globalTeamData.allPlayers when loading plan.`);
                                return null; // Or handle this gracefully, e.g., by creating a placeholder player
                            }
                        }).filter(Boolean); // Remove any nulls if playerDetails wasn't found

                        currentPlanningRound = selectedPlan.data.currentRound || INITIAL_PLANNING_ROUND; 
                        currentFreeTransfers = selectedPlan.data.currentFreeTransfers !== undefined ? selectedPlan.data.currentFreeTransfers : 1;
                        currentPointsHit = selectedPlan.data.currentPointsHit !== undefined ? selectedPlan.data.currentPointsHit : 0;
                        currentFunds = selectedPlan.data.currentFunds !== undefined ? selectedPlan.data.currentFunds : 100.0;
                        pendingTransfers = selectedPlan.data.pendingTransfers ? selectedPlan.data.pendingTransfers.map(t => ({
                            type: t.type,
                            player: globalTeamData.allPlayers.find(p => p.id === t.playerId), // Re-fetch full player object
                            newSlotId: t.newSlotId,
                            newSlotType: t.newSlotType
                        })).filter(t => t.player) : []; // Filter out if player not found

                        renderSquad(currentSquad, currentPlanningRound);
                        updateTransferSummary();
                        filterAndRenderPlayerList(); // Update player list after loading squad
                        showTransferPlannerMessage(`Plan "${selectedPlan.name}" loaded successfully!`, 'success');
                    } else {
                        showTransferPlannerMessage('Plan not found.', 'error');
                    }

                } catch (error) {
                    console.error("Error loading plan:", error);
                    showTransferPlannerMessage(`Failed to load plan: ${error.message}`, 'error');
                }
            });
        }

        if (resetPlanButton) { // Check if element exists before adding listener
            resetPlanButton.addEventListener('click', () => {
                showTransferPlannerMessage('Resetting current plan...', 'info');
                initializeTransferPlanner(); // Re-initialize to the starting state
            });
        }

        // Player List Filtering Buttons
        if (playerFilters) { // Check if element exists before adding listener
            playerFilters.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', () => {
                    playerFilters.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    activePlayerFilter = button.dataset.filter;
                    filterAndRenderPlayerList();
                });
            });
        }

        // Player Search Input
        if (playerSearchInput) { // Check if element exists before adding listener
            playerSearchInput.addEventListener('input', () => {
                filterAndRenderPlayerList();
            });
        }


        // Initial Load
        document.addEventListener('DOMContentLoaded', () => {
            if (auth.currentUser) { 
                if (loggedInContent) loggedInContent.style.display = 'block'; 
                if (authSection) authSection.style.display = 'none'; 
                showContentSection('initialLoggedInDashboard'); 
            }
            else { 
                if (authSection) authSection.style.display = 'block'; 
                if (loginForm) loginForm.style.display = 'block'; 
                if (signupForm) signupForm.style.display = 'none'; 
                if (loggedInContent) loggedInContent.style.display = 'none'; 
            }
            if (instructionsBox) instructionsBox.style.display = 'none';

            if (darkModeToggle) {
                const savedTheme = localStorage.getItem('theme'); setTheme(savedTheme || 'light');
                darkModeToggle.addEventListener('change', (e) => setTheme(e.target.checked ? 'dark' : 'light'));
            }

            if (menuToggle && sidebarMenu && overlay) {
                menuToggle.addEventListener('click', () => { sidebarMenu.classList.toggle('open'); overlay.style.display = sidebarMenu.classList.contains('open') ? 'block' : 'none'; });
                overlay.addEventListener('click', () => { sidebarMenu.classList.remove('open'); overlay.style.display = 'none'; });
            }

            if (menuMyControlRoom) { menuMyControlRoom.addEventListener('click', (e) => { e.preventDefault(); showContentSection('controlRoom'); sidebarMenu.classList.remove('open'); overlay.style.display = 'none'; }); }
            if (menuAdminDashboard) { menuAdminDashboard.addEventListener('click', (e) => { e.preventDefault(); showContentSection('adminDashboard'); sidebarMenu.classList.remove('open'); overlay.style.display = 'none'; }); }

            // Initialize slider values
            if (roundsToShowSlider && roundsToShowValueSpan) { roundsToShowValueSpan.textContent = roundsToShowSlider.value; }
            if (roundsToShowTeamsToTargetSlider && roundsToShowValueTeamsToTargetSpan) { roundsToShowValueTeamsToTargetSpan.textContent = roundsToShowTeamsToTargetSlider.value; }
        });
    </script>
</body>
</html>
